<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1250">
<TITLE>SHA-1</TITLE>
<link rel="stylesheet" type="text/css" href="CrypTool_Help.css">
</HEAD>

<!-- multiple keywords for CrypTool HTML help index -->
<OBJECT TYPE="application/x-oleobject" CLASSID="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
	<PARAM NAME="Keyword" VALUE="Hash function">
	<PARAM NAME="Keyword" VALUE="SHA-1 hash value">
</OBJECT>

<BODY>

<h3>SHA-1 (Menu <A href="menu_related_methods.html">Algorytmy</A></B> \ Hasz)</h3>

<P>Algorytm SHA-1 tworzy <!--ZZZPOPUP--><A href="hashwert.html">skrót</A> o d³ugoœci 160 bitów (= 20 bajtów). Obok algorytmu RIPMED-160, SHA-1 (opublikowany przez <!--ZZZPOPUP--><A href="nist.html">NIST</A> w 1991) jest najczêœciej u¿ywan¹ funkcj¹ haszuj¹c¹.</P>

<P>Algorytm jest przedstawiony w dokumencie FIPS180-1, kwintesencja tego dokumentu zosta³a przedstawiona poni¿ej.</P>

<P><B>1. POWIÊKSZANIE WIADOMOŒCI</B></P>

<P>SHA-1 jest u¿ywany do obliczenia skrótu dla wiadomoœci lub pliku który jest dostarczony na wejœcie. Wiadomoœæ lub plik jest rozwa¿any jako ci¹g bitów. D³ugoœæ wiadomoœci jest liczb¹ bitów w wiadomoœci (pusta wiadomoœæ ma d³ugoœæ równ¹ 0). Je¿eli liczba bitów w wiadomoœci jest wielokrotnoœci¹ 8, dla u³atwienia mo¿emy przedstawiaæ wiadomoœæ w postaci szesnastkowej. Celem powiêkszania wiadomoœci jest to ¿eby ca³kowita d³ugoœæ powiêkszonej wiadomoœci by³a wielokrotnoœci¹ 512. SHA-1 sekwencyjnie przetwarza bloki o d³ugoœci 512 bitów podczas obliczania skrótu wiadomoœci. Poni¿sza specyfikacja przedstawia jak powiêkszenie wiadomoœci powinno zostaæ wykonane. Do wiadomoœci dopisujemy "1" a potem m "0" oraz 64 bitow¹ liczê ca³kowit¹ równ¹ d³ugoœci oryginalnej wiadomoœci, tak aby ca³a ca³kowita d³ugoœæ takiej wiadomoœci by³a podzielna przez 512. Powiêkszona wiadomoœæ jest wtedy przetwarzana przez SHA-1 jako n bloków o d³ugoœci 512 bitów.</P>

<P>Powiêkszona wiadomoœæ bêdzie zawiera³a 16 * n s³ów dla pewnego n &gt; 0. Powiêkszona wiadomoœæ jest reprezentowany jako ci¹g n bloków M<SUB>1</SUB>, M<SUB>2</SUB>,..., M<SUB>n</SUB>, gdzie ka¿dy M<SUB>i</SUB> zawiera 16 s³ów i M<SUB>1</SUB> zawiera pierwsze litery (lub bity) wiadomoœci.</P>

<P><B>2. U¯YWANE FUNKCJE</B></P>

<P>SHA-1 wykorzystuje ci¹g funkcji f<SUB>0</SUB>, f<SUB>1</SUB>,..., f<SUB>79</SUB>. Ka¿da funkcja f<SUB>t</SUB>, 0 &lt;= t &lt;= 79, operuje na trzech 32-bitowych s³owach B, C, D i tworzy 32-bitowe s³owo na wyjœciu. f<SUB>t</SUB>(B,C,D) jest zdefiniowana nastêpuj¹co: dla s³ów B, C, D</P>

<PRE><CODE>f<SUB>t</SUB>(B,C,D) = (B AND C) OR ((NOT B) AND D) (dla 0 &lt;= t &lt;= 19) 
f<SUB>t</SUB>(B,C,D) = B XOR C XOR D (20 &lt;= t &lt;= 39) 
f<SUB>t</SUB>(B,C,D) = (B AND C) OR (B AND D) OR (C AND D) (dla 40 &lt;= t &lt;= 59) 
f<SUB>t</SUB>(B,C,D) = B XOR C XOR D (dla 60 &lt;= t &lt;= 79).</CODE></PRE>

<P><B>3. U¯YWANE STA£E</B></P>

<P>SHA-1 wykorzystuje ci¹g sta³ych s³ów K(0), K(1),..., K(79). Ich wartoœci w systemie szesnastkowym wynosz¹:</P>

<PRE><CODE>K<SUB>t</SUB> = 0x5A827999 (dla 0 &lt;= t &lt;= 19) 
K<SUB>t</SUB> = 0x6ED9EBA1 (dla 20 &lt;= t &lt;= 39) 
K<SUB>t</SUB> = 0x8F1BBCDC (dla 40 &lt;= t &lt;= 59) 
K<SUB>t</SUB> = 0xCA62C1D6 (dla 60 &lt;= t &lt;= 79). </CODE></PRE>

<P><B>4. OBLICZANIE SKRÓTU WIADOMOŒCI</B></P>

<P>Skrót wiadomoœci jest obliczany przy u¿yciu powiêkszonej wiadomoœci. Obliczenia wymagaj¹ dwóch buforów (ka¿dy sk³adaj¹cy siê z piêciu 32 bitowych s³ów) i ci¹gu osiemdziesiêciu 32 bitowych s³ów. S³owa pierwszego bufora s¹ oznaczane jako A, B, C, D, E, a drugiego H<SUB>0</SUB>, H<SUB>1</SUB>, H<SUB>2</SUB>, H<SUB>3</SUB>, H<SUB>4</SUB>. S³owa 80 wyrazowego ci¹gu s¹ oznaczane jako W<SUB>0</SUB>, W<SUB>1</SUB>,..., W<SUB>79</SUB>. Jest równie¿ wykorzystywany bufora TEMP o d³ugoœci pojedynczego s³owa.</P>

<P>Aby wygenerowaæ skrót wiadomoœci, bloki M<SUB>1</SUB>, M<SUB>2</SUB>,..., M<SUB>n</SUB> sk³adaj¹ce siê z 16 s³ów zdefiniowanych dok³adnie w punkcie 4, s¹ odpowiednio przetwarzane. Przetworzenie ka¿dego M<SUB>i</SUB> wymaga 80 kroków.</P>

<P>Przed przetworzeniem bloków, inicjalizujemy {H<SUB>i</SUB>} w nastêpuj¹cy sposób: w systemie szesnastkowym, </P>

<PRE><CODE>H<SUB>0</SUB> = 0x67452301 
H<SUB>1</SUB> = 0xEFCDAB89 
H<SUB>2</SUB> = 0x98BADCFE 
H<SUB>3</SUB> = 0x10325476 
H<SUB>4</SUB> = 0xC3D2E1F0. </CODE></PRE>

<P>Teraz przetwarzamy M<SUB>1</SUB>, M<SUB>2</SUB>,..., M<SUB>n</SUB>. Aby przetworzyæ M<SUB>i</SUB>, wykonujemy nastêpuj¹ce czynnoœci: </P>

<OL type="a">

	<LI> Podziel M<SUB>i</SUB> na 16 s³ów W<SUB>0</SUB>, W<SUB>1</SUB>,..., W<SUB>15</SUB>, gdzie W<SUB>0</SUB> jest s³owem najbardziej od lewej.<BR><BR></LI> 
	<LI> Dla t = 16 do 79 niech W<SUB>t</SUB> = S<SUP>1</SUP>(W<SUB>t-3</SUB> XOR W<SUB>t-8</SUB> XOR W<SUB>t- 14</SUB> XOR W<SUB>t-16</SUB>).<BR><BR></LI> 
	<LI> Niech A = H<SUB>0</SUB>, B = H<SUB>1</SUB>, C = H<SUB>2</SUB>, D = H<SUB>3</SUB>, E = H<SUB>4</SUB>.<BR><BR></LI>
	<LI> Dla t = 0 do 79 wykonaj 
TEMP = S<SUP>5</SUP>(A) + f<SUB>t</SUB>(B,C,D) + E + W<SUB>t</SUB> + K<SUB>t</SUB>; 
E = D; D = C; C = S<SUP>30</SUP>(B); B = A; A = TEMP;<BR><BR></LI> 
	<LI> Niech H<SUB>0</SUB> = H<SUB>0</SUB> + A, H<SUB>1</SUB> = H<SUB>1</SUB> + B, H<SUB>2</SUB> = H<SUB>2</SUB> + C, H<SUB>3</SUB> = H<SUB>3</SUB> + D, H<SUB>4</SUB> = H<SUB>4</SUB> + E. <BR><BR></LI>

</OL>

<P>Po przetworzeniu M<SUB>n</SUB>, skrót wiadomoœci jest 160-bitowym ci¹giem reprezentowanym przez 5 s³ów </P>

<PRE><CODE>H<SUB>0</SUB> H<SUB>1</SUB> H<SUB>2</SUB> H<SUB>3</SUB> H<SUB>4</SUB>.</CODE></PRE>

</BODY>
</HTML>
