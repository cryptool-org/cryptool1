<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1250">
<TITLE>MD5 hash value</TITLE>
<link rel="stylesheet" type="text/css" href="CrypTool_Help.css">
</HEAD>

<!-- multiple keywords for CrypTool HTML help index -->
<OBJECT type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
	<PARAM NAME="Keyword" VALUE="Hash function">
	<PARAM NAME="Keyword" VALUE="MD5 hash value">
</OBJECT>

<BODY>

<h3>Wartoœæ hasza MD5 (Menu <A href="menu_related_methods.html">Algorytmy</A> \ Hasz)</h3>

<P>Algorytm MD5 produkuje <!--ZZZPOPUP--><A href="hashwert.html">wartoœæ hasza</A> o d³ugoœci 128 bitów (= 16 bajtów).</P>

<P>Algorytm jest opisany w RFC 1321 (RequestForComment URL http://www.faqs.org/rfcs/rfc1321.html), najwa¿niejsze informacje z niego s¹ zamieszczone poni¿ej.</P>

<P><B>Krok 1. Do³¹czanie Bitów Wyrównania</B></P>

<P>Wiadomoœæ jest "wyrównywana" (rozszerzana) tak, aby jej d³ugoœæ (w bitach) by³a zgodna z 448, modulo 512. To znaczy, ¿e wiadomoœæ jest rozszerzana tak, ¿e tylko 64 bity powoduj¹ bycie niepodzielnymi przez 512 bitow¹ d³ugoœæ. Wyrównanie jest zawsze wykonywane, tak¿e gdy d³ugoœæ wiadomoœci jest ju¿ zgodna z 448, modulo 512. Wyrównanie jest przeprowadzane nastêpuj¹co: pojedynczy bit "1" jest dodawany do wiadomoœci, potem bity "0" s¹ dodawane tak, ¿eby d³ugoœæ wyrównanej wiadomoœci w bitach by³a zgodna z 448, modulo 512. W sumie przynajmniej jeden bit i co najwy¿ej 512 bitów jest do³¹czonych.

<PRE></PRE>

<P><B>Krok 2. Do³¹czanie D³ugoœci</B></P>

<P>64-bitowa reprezentacja b (d³ugoœæ wiadomoœci przed dodaniem bitów dope³nienia) jest do³¹czana do rezultatu otrzymanego w poprzednim kroku. Jeœli w ma³oprawdopodobnym przypadku b jest wiêksze ni¿ 2^64, wtedy tylko m³odsze 64 bity s¹ u¿ywane. (Te bity s¹ do³¹czane jako dwa 32-bitowe s³owa i do³¹czanie jako m³odsze s³owo zgodnie z poprzedni¹ konwencj¹.) W tym momencie wynikowa wiadomoœæ (po dope³nieniu bitami i z b) ma d³ugoœæ, która jest dok³adnie wielokrotnoœci¹ 512 bitów. Równowa¿nie, ta wiadomoœæ ma d³ugoœæ, która jest dok³adn¹ wielokrotnoœci¹ 16 (32-bitowego) s³owa. Niech M[0... N-1] oznacza s³owa wynikowej wiadomoœci, gdzie N jest wielokrotnoœci¹ 16.</P>

<PRE></PRE>

<P><B>Krok 3. Inicjacja Bufora MD</B></P>

<P>Cztero-liczbowy bufor (A,B,C,D) jest u¿yty do obliczenia skrótu wiadomoœci. Ka¿da z liczb A, B, C, D jest 32-bitowym rejestrem. Te rejestry s¹ inicjowane nastêpuj¹cymi rejestrami heksadecymalnymi, mniej znacz¹ce bajty pierwsze):</P>

<PRE><CODE>s³owo A: 01 23 45 67
s³owo B: 89 ab cd ef
s³owo C: fe dc ba 98
s³owo D: 76 54 32 10
</CODE></PRE>

<P><B>Krok 4. Przetwarzanie Wiadomoœci W blokach 16-liczbowych</B></P>

<P>Na pocz¹tku zdefiniujemy pomocnicz¹ funkcje, która przyjmujê na wejœciu trzy 32-bit s³owa i daje na wyjœciu jedno 32-bitowe s³owo.</P>

<PRE><CODE>F(X,Y,Z) = XY v not(X) Z
G(X,Y,Z) = XZ v Y not(Z)
H(X,Y,Z) = X xor Y xor Z
I(X,Y,Z) = Y xor (X v not(Z))</CODE></PRE>

<P>Ka¿dy bit pozycji F zachowuje siê warunkowo: jeœli X wtedy Y w przeciwnym razie Z. Funkcja F powinna byæ zdefiniowana za pomoc¹ + zamiast v kiedy XY i not(X)Z nie maja nigdy 1‚s na tej samej pozycji.) Warto zaznaczyæ, ¿e jeœli bity X, Y, i Z s¹ niezale¿ne i niesystematyczne, wtedy ka¿dy bit F(X,Y,Z) bêdzie niezale¿ny i niesystematyczny. Funkcje G, H, i I s¹ podobne do funkcji F, w tym sensie, ¿e zachowuj¹ siê "bitowo równolegle" - produkuj¹ swoje wyjœcia z bitów X, Y, i Z, w ten sposób, ¿e jeœli odpowiadaj¹ce bity X, Y, i Z s¹ niezale¿ne i niesystematyczne, wtedy ka¿dy bit  G(X,Y,Z), H(X,Y,Z), and I(X,Y,Z) bêdzie niezale¿ny i niesystematyczny. Zauwa¿, ¿e funkcja H jest bitowym "xor-em" lub "parzystoœci¹" dla jej argumentów wejœciowych.</P>

<P>Ten krok korzysta z 64 elementowej tablicy T[1... 64] skonstruowanej z funkcji sinus. Niech T[i] oznacza i-ty element tablicy, który jest równy ca³kowitej czêœci 4294967296 razy abs(sin(i)), gdzie i jest podane w radianach. Elementy tablicy s¹ podane w dodatku.</P>

<P>Zrób nastêpuj¹ce czynnoœci:</P>

<PRE><CODE>/* Przetwórz ka¿dy 16-liczbowy blok. */
For i = 0 to N/16-1 do /* Skopiuj blok do X. */
    For j = 0 to 15 do
        Set X[j] to M[i*16+j].
    end /* of loop on j */
    /* Zapisz A jako AA, B jako BB, C jako CC, i D jako DD. */
    AA = A
    BB = B
    CC = C
    DD = D
    /* Runda 1. */
    /* Niech [abcd k s i] oznacza operacjê a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */
    /* Wykonaj 16 nastêpuj¹cych operacji. */
    [ABCD 0 7 1]  [DABC 1 12 2]  [CDAB 2 17 3]  [BCDA 3 22 4]
    [ABCD 4 7 5]  [DABC 5 12 6]  [CDAB 6 17 7]  [BCDA 7 22 8]
    [ABCD 8 7 9]  [DABC 9 12 10] [CDAB 10 17 11] [BCDA 11 22 12]
    [ABCD 12 7 13] [DABC 13 12 14] [CDAB 14 17 15] [BCDA 15 22 16]
    /* Runda 2. */
    /* Niech [abcd k s i] oznacza operacjê a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */
    /* Wykonaj 16 nastêpuj¹cych operacji. */
    [ABCD 1 5 17] [DABC 6 9 18] [CDAB 11 14 19] [BCDA 0 20 20]
    [ABCD 5 5 21] [DABC 10 9 22] [CDAB 15 14 23] [BCDA 4 20 24]
    [ABCD 9 5 25] [DABC 14 9 26] [CDAB 3 14 27] [BCDA 8 20 28]
    [ABCD 13 5 29] [DABC 2 9 30] [CDAB 7 14 31] [BCDA 12 20 32]
    /* Runda 3. */
    /* Niech [abcd k s t] oznacza operacjê a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */
    /* Wykonaj 16 nastêpuj¹cych operacji. */
    [ABCD 5 4 33] [DABC 8 11 34] [CDAB 11 16 35] [BCDA 14 23 36]
    [ABCD 1 4 37] [DABC 4 11 38] [CDAB 7 16 39] [BCDA 10 23 40]
    [ABCD 13 4 41] [DABC 0 11 42] [CDAB 3 16 43] [BCDA 6 23 44]
    [ABCD 9 4 45] [DABC 12 11 46] [CDAB 15 16 47] [BCDA 2 23 48]
    /* Runda 4. */
    /* Niech [abcd k s t] oznacza operacjê a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */
    /* Wykonaj 16 nastêpuj¹cych operacji. */
    [ABCD 0 6 49] [DABC 7 10 50] [CDAB 14 15 51] [BCDA 5 21 52]
    [ABCD 12 6 53] [DABC 3 10 54] [CDAB 10 15 55] [BCDA 1 21 56]
    [ABCD 8 6 57] [DABC 15 10 58] [CDAB 6 15 59] [BCDA 13 21 60]
    [ABCD 4 6 61] [DABC 11 10 62] [CDAB 2 15 63] [BCDA 9 21 64]
    /* Wykonaj nastêpuj¹ce uzupe³nienie. (Inkrementacja ka¿dego z czterech rejestrów o wartoœæ jak¹ mia³ przed rozpoczêciem tego bloku.) */
    A = A + AA
    B = B + BB
    C = C + CC
    D = D + DD
end /* pêtli na i */
</CODE></PRE>

<P><B>Krok 5. Wyjœcie</B></P>

<P>Skrót wiadomoœci wyprodukowany jako wyjœcie A, B, C, D. To znaczy - zaczynamy od najni¿szych adresów - A, a koñczymy na adresach najwy¿szych - D. To koñczy opis algorytmu MD5. Odwo³anie do implementacji w C jest w dodatku.</P>
</BODY>
</HTML>
