/*
 *  MIRACL - various implementations of routines muldiv, muldvm and muldvd
 *  mrmuldv.c
 *
 *  THIS FILE CONTAINS MANY VERSIONS OF THESE THREE ROUTINES
 *  COPY THIS FILE TO MRMULDV.C AND DELETE THOSE PARTS IRRELEVANT TO
 *  YOUR REQUIREMENTS. 
 *
 *  NOTE: - This file and its contents are not needed 
 *  if MR_NOASM is defined in mirdef.h
 * 
 *  muldiv() calculates (a*b+c)/m and (a*b+c)%m as quickly as possible. Should 
 *  ideally be written in assembly language of target machine for speed 
 *  The problem is to avoid overflow in the calculation of the intermediate 
 *  product a*b+c. 
 *
 *  muldvm() and muldvd() routines are necessary to support full-width number 
 *  base working. They are not needed if MR_NOFULLWIDTH is defined in mirdef.h.
 *
 *  muldvm - returns (a*base+c)/m and remainder
 *  muldvd - returns (a*b+c)/base and remainder 
 *
 *  NOTE: New to version 4.2, new routine muldvd2() is required.
 *  See C version below for specification
 *  Versions of this are easily developed from existing muldvd() programs
 *
 *  In most applications muldvd2() will be the time critical routine.
 *
 *  Note that full-width base working may not be possible for all processors. 
 *  For example it cannot be used on a VAX, or RS/6000 with mr_utypes defined as 
 *  ints. This is because the instruction set does not support 
 *  unsigned multiply and divide instructions. In such cases ALWAYS use a 
 *  maximum base of MAXBASE in mirsys(), rather than 0.
 *
 *  Since parameter passing and returning is time-consuming, these routines 
 *  should be generated 'inline', if compiler allows it. Parameter passing
 *  by register will also be faster than via the stack. For even faster 
 *  operation, use in-line assembly to speed up the inner loops of routines 
 *  pmul(), sdiv(), multiply() and divide(). See these routines for details 
 *  of Microsoft/Borland C inline 80x86 assembly, which gives a substantial speed-up.
 *
 *  NOTE: All other things being equal, versions of MIRACL with 32-bit mr_utypes
 *  will run 3-4 times faster than versions with 16-bit mr_utypes, even for medium
 *  precision arithmetic, such as used in Public Key systems. 
 *  
 *  Note that a portable C version of 'muldiv' is not possible on most 32-bit
 *  computers, as ints and longs are both 32-bits (but see Blakely-Sloan 
 *  method below). The portable versions may be used however if mr_utypes are 
 *  defined as shorts, usually 16 bits. This would amount however to 
 *  using the 32-bit processor in a 16 bit mode and would be very inefficient 
 *  - up to 4 times slower. See mirdef.haf 
 *
 *  First the standard portable versions, for use when there is a double 
 *  length type capable of holding the product of two mr_utype types.
 *  Usually 32 and 16 bits types respectively. 
 *  Note that if MR_NOASM is defined in mirdef.h, these routines are 
 *  implemented in mrcore.c, and do not need to be extracted from here.
 *  Note:- MR_TOP() is defined in miracl.h. Its the top half of the double-
 *  length product.
 * 
 *  This is followed by various other assembly language implementations for 
 *  popular processors, computers and compilers.
 *

#include <stdio.h>
#include <miracl.h>

mr_small muldiv(a,b,c,m,rp)
mr_small a,b,c,m,*rp;
{
    mr_small q;
    mr_large dble=(mr_large)a*b+c;
    q=(mr_small)(dble/m);
    *rp=(mr_small)(dble-(mr_large)q*m);
    return q;
}

mr_small muldvm(a,c,m,rp)
mr_small a,c,m,*rp;
{
    mr_small q;
    mr_large dble=c;
    MR_TOP(dble)=a;
    q=(mr_small)(dble/m);
    *rp=(mr_small)(dble-(mr_large)q*m);
    return q;
}

mr_small muldvd(a,b,c,rp)
mr_small a,b,c,*rp;
{
    mr_large dble=(mr_large)a*b+c;
    *rp=(mr_small)dble;
    return MR_TOP(dble);
}

void muldvd2(mr_small a,mr_small b,mr_small *c,mr_small *rp)
{
    mr_large dble=(mr_large)a*b+*c+*rp;
    *rp=(mr_small)dble;
    *c=MR_TOP(dble);
}

;
;   VAX11 version for Dec C compiler
;   with 32 bit int using 64-bit quadword
;   for the intermediate product. 
;
;   Use with mirdef.h32 - but define MR_NOFULLWIDTH 
;   Use mirsys(...,MAXBASE) instead of mirsys(...,0) in your programs. 
;   
;   Why ...(MIRACL-2) instead of ...(MIRACL-1) ? That's a negative
;   number for division by mr_base!
;
;   The problem is that the emul and ediv instructions work only
;   for signed types
;
    .entry muldiv,0
    subl   #4,sp
    emul   4(ap),8(ap),12(ap),r0   ;a*b+c
    ediv   16(ap),r0,r0,@20(ap)    ;quo. in r0, rem. in *rp
    ret
    .end
;
;   Fullwidth base working not possible on VAX, so no muldvm() or muldvd()
;   Empty dummies implemented in mrcore.c to satisfy linker
;

#
#    Version of muldiv.c for IBM RS/6000
#    This processor has no unsigned multiply/divide
#    so full-width base not possible, so no muldvm() or muldvd()
#
#    Use with mirdef.h32 but define MR_NOFULLWIDTH definition.
#    Use mirsys(...,MAXBASE) instead of mirsys(...,0) in your programs. 
#
#    Note this version was developed from very inadequate RS/6000
#    documentation. It may not be optimal, and it may not always work
#    (although it works fine for me!)
#    

                                   
        .file   "mrmuldv.s"
        .globl  .muldiv[PR]
        .csect  .muldiv[PR]

# parameters are passed in registers 3,4,5,6 and 7
# the mq register holds the low 32-bits for mul/div

        mul     3,4,3          # q=a*b
        mfmq    4              # get low part from mq
        a       4,5,4          # add in c
        aze     3,3            # add carry to high part
        mtmq    4              # move low part to mq
        div     3,3,6          # q=(a*b+c)/m
        mfmq    4              # get remainder 
        st      4,0(7)         # store remainder

# quotient is returned in register 3

        brl

/* Here's another portable method which might be considered for processors
 * like the VAX and RS6000. The idea is due to Peter Montgomery.  */

    #include <mirdef.h>

    typedef unsigned mr_utype uint;

    uint muldiv(a,b,c,m,rp)
    uint a,b,c,m,*rp;
    {
        int q,r;
        q=(int)(0.5+((double)a*(double)b+(double)c)/(double)m);
        r=(int)(((uint)a*(uint)b+(uint)c)-(uint)m*(uint)q);
        if (r < 0)
        {
            r+=m;
            q--;
        }
        *rp=r;
        return q;
    }

;
;  IBM-PC versions - small memory model only
;  Easily modified for other memory models
;
;  For large code models (e.g. medium)
;
;           change    _TEXT    to    mrmuldv_TEXT  (in three places)
;           change    NEAR     to    FAR
;           change    [bp+4]   to    [bp+6]
;           change    [bp+6]   to    [bp+8]
;           change    [bp+8]   to    [bp+10]
;           change    [bp+10]  to    [bp+12]
;           change    [bp+12]  to    [bp+14]
;
;  For large data models, see Turbo C version below for required modification
;
;  Microsoft C compiler V4.0+
;  Written for MS macro-assembler
;
        ASSUME CS:_TEXT
_TEXT   SEGMENT BYTE PUBLIC 'CODE'

        PUBLIC _muldiv
_muldiv PROC NEAR
        push bp                 ;standard C linkage
        mov  bp,sp

        mov  ax,[bp+4]          ;get a
        mul  WORD PTR [bp+6]    ;multiply by b
        add  ax,[bp+8]          ;add c to low word
        adc  dx,0h              ;add carry to high word
        div  WORD PTR [bp+10]   ;divide by m
        mov  bx,[bp+12]         ;get address for remainder
        mov  [bx],dx            ;store remainder

        pop  bp                 ;standard C return
        ret                     ;quotient in ax

_muldiv endP

        PUBLIC _muldvm
_muldvm PROC NEAR
        push bp                 ;standard C linkage
        mov  bp,sp

        mov  dx,[bp+4]          ;get a
        mov  ax,[bp+6]          ;add in c
        div  WORD PTR [bp+8]    ;divide by m
        mov  bx,[bp+10]         ;get address for remainder
        mov  [bx],dx            ;store remainder

        pop  bp                 ;standard C return
        ret                     ;quotient in ax

_muldvm endP

        PUBLIC _muldvd
_muldvd PROC NEAR
        push bp                 ;standard C linkage
        mov  bp,sp

        mov  ax,[bp+4]          ;get a
        mul  WORD PTR [bp+6]    ;multiply by b
        add  ax,[bp+8]          ;add c to low word
        adc  dx,0h              ;add carry to high word
        mov  bx,[bp+10]         ;get address for remainder
        mov  [bx],ax            ;store remainder
        mov  ax,dx
        pop  bp                 ;standard C return
        ret                     ;quotient in ax

_muldvd endP

        PUBLIC _muldvd2
_muldvd2 PROC NEAR
        push bp                 ;standard C linkage
        mov  bp,sp
        push si

        mov  ax,[bp+4]          ;get a
        mul  WORD PTR [bp+6]    ;multiply by b
        mov  bx,[bp+8]          ;get address for c
        add  ax,[bx]            ;add c
        adc  dx,0h              ;add carry to high word

        mov  si,[bp+10]         ;get address for remainder
        add  ax,[si]            ;add rp
        adc  dx,0h              ;add carry to high word

        mov  [si],ax            ;store remainder
        mov  [bx],dx            ;store carry

        pop  si
        pop  bp                 ;standard C return
        ret  

_muldvd2 endP



_TEXT   ENDS
END

/*
 *  Turbo C compiler V1.5+, Turbo/Borland C++. Microsoft C/C++ 
 *  Uses inline assembly feature
 *  Generates code identical to above version, and
 *  can be used instead. 
 */

#define ASM _asm

unsigned int muldiv(a,b,c,m,rp)
unsigned int a,b,c,m,*rp;
{
    ASM mov  ax,a             ;/* get a                     */
    ASM mul  WORD PTR b       ;/* multiply by b             */
    ASM add  ax,c             ;/* add c to low word         */
    ASM adc  dx,0h            ;/* add carry to high word    */
    ASM div  WORD PTR m       ;/* divide by m               */
    ASM mov  bx,rp            ;/* get address for remainder */
    ASM mov  [bx],dx          ;/* store remainder           */
}
/*    Replace last two ASM lines when using large data memory models */
/*    ASM les  bx, DWORD PTR rp          ; get address for remainder */
/*    ASM mov  WORD PTR es:[bx],dx       ; store remainder           */

unsigned int muldvm(a,c,m,rp)
unsigned int a,c,m,*rp;
{
    ASM mov dx,a              ;/* get a                     */
    ASM mov ax,c              ;/* add in c to low word      */
    ASM div WORD PTR m        ;/* divide by m               */
    ASM mov bx,rp             ;/* get address for remainder */
    ASM mov [bx],dx           ;/* store remainder           */
}
/*    Replace last two ASM lines when using large data memory models */
/*    ASM les  bx, DWORD PTR rp          ; get address for remainder */
/*    ASM mov  WORD PTR es:[bx],dx       ; store remainder           */

unsigned int muldvd(a,b,c,rp)
unsigned int a,b,c,*rp;
{
    ASM mov  ax,a             ;/* get a                     */
    ASM mul  WORD PTR b       ;/* multiply by b             */
    ASM add  ax,c             ;/* add c to low word         */
    ASM adc  dx,0h            ;/* add carry to high word    */
    ASM mov  bx,rp            ;/* get address for remainder */
    ASM mov  [bx],ax          ;/* store remainder           */
    ASM mov  ax,dx
}
/*    Replace second and third last lines if using large data memory models */
/*    ASM les  bx, DWORD PTR rp          ; get address for remainder */
/*    ASM mov  WORD PTR es:[bx],ax       ; store remainder           */

void muldvd2(a,b,c,rp)
unsigned int a,b,*c,*rp;
{
    ASM mov  ax,a             ;/* get a                     */
    ASM mul  WORD PTR b       ;/* multiply by b             */
    ASM mov  bx,c
    ASM add  ax,[bx]
    ASM adc  dx,0h            ;/* add carry to high word    */
    ASM mov  si,rp
    ASM add  ax,[si]
    ASM adc  dx,0h
    ASM mov  [si],ax
    ASM mov  [bx],dx
}

/* for large memory model ....
    ASM mov  ax,a             ;/* get a                     */
    ASM mul  WORD PTR b       ;/* multiply by b             */
    ASM les  bx, DWORD PTR c
    ASM add  ax, WORD PTR es:[bx]
    ASM adc  dx,0h            ;/* add carry to high word    */
    ASM les  si,DWORD PTR rp
    ASM add  ax,WORD PTR es:[si]
    ASM adc  dx,0h
    ASM mov  WORD PTR es:[si],ax
    ASM les  bx,DWORD PTR c
    ASM mov  WORD PTR es:[bx],dx
*/


;
;  IBM-PC-8087 for Microsoft C compiler V4.0+
;  with 'mr_utype' defined as 'long' (32 bit). See mirdef.hpc
;  This allows IBM-PC XT to look a bit like a 32-bit computer
;  (which it isn't). To make use of this option:
;
;  (1) Must have 8087 Maths Co-processor (for speed and to hold 64-bit
;      intermediate product).
;
;  (2) Must use 'ANSI' enhanced type C compiler, e.g. Microsoft V3.0+
;      and must use header 'miracl.h' which declares function
;      parameter types. 
;
;      Note: some compilation warnings may be generated - ignore them.  
;
;  Note: This is NOT, in most cases, faster, but it does allow
;        very high precision calculations, e.g. 1000!
;
;  Note: No versions of muldvm(), muldvd() or muldvd2() yet written for 
;  this method.
;
        ASSUME CS:_TEXT
_TEXT   SEGMENT BYTE PUBLIC 'CODE'

        PUBLIC _muldiv
_muldiv PROC NEAR
        push si                 ;standard C linkage
        push bp          
        mov  bp,sp

        finit                   ;initialise 8087
        fild  DWORD PTR [bp+6]  ;get a
        fimul DWORD PTR [bp+0ah];multiply by b
        fiadd DWORD PTR [bp+0eh];add c
        fild  DWORD PTR [bp+12h];get m
        fld st(1)               ;duplicate a*b+c on stack
        fprem                   ;get remainder
        fist  DWORD PTR [bp+0ah];store remainder in b
        fsubr st,st(2)          ;subtract rem from total
        fdiv st,st(1)           ;divide by m
        fist  DWORD PTR [bp+6]  ;store quotient in a
        wait

        mov  si,[bp+22]         ;get address for remainder
        mov  ax,[bp+10]
        mov  dx,[bp+12]         ;get remainder
        mov  [si],ax
        mov  [si+2],dx          ;store remainder
        mov  ax,[bp+6]
        mov  dx,[bp+8]          ;get quotient in dx:ax

        pop  bp                 ;standard C return
        pop  si
        ret

_muldiv endP

_TEXT   ENDS
END

;
;  Intel-80386 pseudo-32 bit version - for Microsoft C V5.0+
;  Written for MS macro-assembler V5.0+ by Andrej Sauer 
;  with 'mr_utype' defined as 'long' (32 bit). See mirdef.hpc
;  Same comments apply as above (except for 8087 requirement)   
;  Note that this version will also work with the latest Zortech and
;  Borland 16-bit compilers, specifically Borland C++ V3.1+
;
;  For large code models (e.g. medium)
;
;           change    _TEXT    to    mrmuldv_TEXT  (in three places)
;           change    NEAR     to    FAR
;           change    [bp+4]   to    [bp+6]
;           change    [bp+8]   to    [bp+10]
;           change    [bp+12]   to   [bp+14]
;           change    [bp+16]  to    [bp+18]
;           change    [bp+20]  to    [bp+22]
;           etc
;
        .386
        ASSUME CS:_TEXT
_TEXT   SEGMENT USE16 PUBLIC 'CODE'

        PUBLIC _muldiv
_muldiv PROC  NEAR
        push  bp                    ;standard C linkage
        mov   bp,sp

        mov   eax,[bp+4]            ;get a
        mul   DWORD PTR [bp+8]      ;multiply by b
        add   eax,DWORD PTR [bp+12] ;add c to low word
        adc   edx,0h                ;add carry to high word
        div   DWORD PTR [bp+16]     ;divide by m
        mov   bx,WORD PTR [bp+20]  ;get address for remainder
        mov   [bx],edx             ;store remainder
        shld  edx,eax,16            ;shift higher half of quotient
                                    ;into lower half of edx

        pop   bp                    ;standard C return
        ret                         ;quotient: high bits in dx, lows in ax

_muldiv endP

        PUBLIC _muldvm
_muldvm PROC  NEAR
        push  bp                    ;standard C linkage
        mov   bp,sp

        mov   edx,[bp+4]            ;get a
        mov   eax,[bp+8]            ;add in c
        div   DWORD PTR [bp+12]     ;divide by m
        mov   bx,WORD PTR [bp+16]   ;get address for remainder
        mov   [bx],edx              ;store remainder
        shld  edx,eax,16            ;shift higher half of quotient
                                    ;into lower half of edx
        pop   bp                    ;standard C return
        ret                         ;quotient: high bits in dx, lows in ax

_muldvm endP


        PUBLIC _muldvd
_muldvd PROC  NEAR
        push  bp                    ;standard C linkage
        mov   bp,sp

        mov   eax,[bp+4]            ;get a
        mul   DWORD PTR [bp+8]      ;multiply by b
        add   eax,DWORD PTR [bp+12] ;add c to low word
        adc   edx,0h                ;add carry to high word
        mov   bx,WORD PTR [bp+16]   ;get address for remainder
        mov   [bx],eax              ;store remainder
        mov   eax,edx
        shld  edx,eax,16            ;shift higher half of quotient
                                    ;into lower half of edx

        pop   bp                    ;standard C return
        ret                         ;quotient: high bits in dx, lows in ax

_muldvd endP


        PUBLIC _muldvd2
_muldvd2 PROC  NEAR
        push  bp                    ;standard C linkage
        mov   bp,sp
        push si

        mov   eax,[bp+4]            ;get a
        mul   DWORD PTR [bp+8]      ;multiply by b
        les   bx,DWORD PTR [bp+12]
        add   eax,DWORD PTR es:[bx]
        adc   edx,0h                ;add carry to high word
        les   si,DWORD PTR [bp+16]
        add   eax,DWORD PTR es:[si]
        adc   edx,0h                ;add carry to high word

        mov   DWORD PTR es:[si],eax              ;store remainder
        les   bx,DWORD PTR [bp+12]
        mov   DWORD PTR es:[bx],edx
        pop   si
        pop   bp                    ;standard C return
        ret           

_muldvd2 endP




_TEXT   ENDS
END

;
; Large Memory model version of the above. Useful
; for creating 16-bit DLL on 386+. Microsoft/Borland compatible
;
        .386
        ASSUME CS:mrmuldv_TEXT
mrmuldv_TEXT   SEGMENT USE16 PUBLIC 'CODE'

        PUBLIC _muldiv
_muldiv PROC  FAR
        push  bp                     ;standard C linkage
        mov   bp,sp

        mov   eax,[bp+6]             ;get a
        mul   DWORD PTR [bp+10]      ;multiply by b
        add   eax,DWORD PTR [bp+14]  ;add c to low word
        adc   edx,0h                 ;add carry to high word
        div   DWORD PTR [bp+18]      ;divide by m
        les   bx,DWORD PTR [bp+22]
        mov   DWORD PTR es:[bx],edx
        shld  edx,eax,16             ;shift higher half of quotient
                                     ;into lower half of edx
        pop   bp                     ;standard C return
        ret                          ;quotient: high bits in dx, lows in ax

_muldiv endP

        PUBLIC _muldvm
_muldvm PROC  FAR
        push  bp                     ;standard C linkage
        mov   bp,sp

        mov   edx,[bp+6]            ;get a
        mov   eax,[bp+10]           ;add in c
        div   DWORD PTR [bp+14]     ;divide by m
        les   bx,DWORD PTR [bp+18]
        mov   DWORD PTR es:[bx],edx
        shld  edx,eax,16            ;shift higher half of quotient
                                    ;into lower half of edx
        pop   bp                    ;standard C return
        ret                         ;quotient: high bits in dx, lows in ax

_muldvm endP


        PUBLIC _muldvd
_muldvd PROC  FAR
        push  bp                     ;standard C linkage
        mov   bp,sp

        mov   eax,[bp+6]            ;get a
        mul   DWORD PTR [bp+10]      ;multiply by b
        add   eax,DWORD PTR [bp+14] ;add c to low word
        adc   edx,0h                 ;add carry to high word
        les   bx,DWORD PTR [bp+18]
        mov   DWORD PTR es:[bx],eax
        mov   eax,edx
        shld  edx,eax,16             ;shift higher half of quotient
                                     ;into lower half of edx

        pop   bp                     ;standard C return
        ret                          ;quotient: high bits in dx, lows in ax

_muldvd endP

        PUBLIC _muldvd2
_muldvd2 PROC  FAR
        push  bp                     ;standard C linkage
        mov   bp,sp
        push  si

        mov   eax,[bp+6]            ;get a
        mul   DWORD PTR [bp+10]      ;multiply by b
        les   bx,DWORD PTR [bp+14]
        add   eax,DWORD PTR es:[bx]
        adc   edx,0h                 ;add carry to high word

        les   si,DWORD PTR [bp+18]
        add   eax,DWORD PTR es:[si]
        adc   edx,0h                 ;add carry to high word

        mov   DWORD PTR es:[si],eax
        les   bx,DWORD PTR [bp+14]
        mov   DWORD PTR es:[bx],edx
        pop   si
        pop   bp                     ;standard C return
        ret                       

_muldvd2 endP

mrmuldv_TEXT   ENDS
END

/* 
   Borland in-line pseudo-32 bit version of the above
   Large memory model version.
   Use with mirdef.hpc

   Unfortunately this cannot be used with Microsoft C, 
   as its 16 bit compiler will not allow inline 386 opcodes
*/

#define ASM _asm

long muldiv(a,b,c,m,rp)
long a,b,c,m,*rp;
{
        ASM mov   eax,DWORD PTR a      
        ASM mul   DWORD PTR b          
        ASM add   eax,DWORD PTR c      
        ASM adc   edx,0h                 
        ASM div   DWORD PTR m          
        ASM les   bx,DWORD PTR rp     
        ASM mov   DWORD PTR es:[bx],edx              
        ASM shld  edx,eax,16
}

long muldvm(a,c,m,rp)
long a,c,m,*rp;
{
        ASM mov   edx,DWORD PTR a      
        ASM mov   eax,DWORD PTR c      
        ASM div   DWORD PTR m          
        ASM les   bx,DWORD PTR rp     
        ASM mov   DWORD PTR es:[bx],edx              
        ASM shld  edx,eax,16
}

long muldvd(a,b,c,rp)
long a,b,c,*rp;
{
        ASM mov   eax,DWORD PTR a      
        ASM mul   DWORD PTR b          
        ASM add   eax,DWORD PTR c      
        ASM adc   edx,0h                 
        ASM les   bx,DWORD PTR rp     
        ASM mov   DWORD PTR es:[bx],eax              
        ASM mov   eax,edx
        ASM shld  edx,eax,16
}

void muldvd2(a,b,c,rp)
long a,b,*c,*rp;
{
        ASM mov   eax,DWORD PTR a      
        ASM mul   DWORD PTR b          
        ASM les   bx,DWORD PTR c
        ASM add   eax,DWORD PTR es:[bx]
        ASM adc   edx,0h                 
        ASM les   si,DWORD PTR rp     
        ASM add   eax,DWORD PTR es:[si]
        ASM adc   edx,0h                 
        ASM mov   DWORD PTR es:[si],eax
        ASM les   bx,DWORD PTR c
        ASM mov   DWORD PTR es:[bx],edx              
}

/*
 *  Borland C++ 32-bit compiler (BCC32). Use with mirdef.h32 
 *  Uses inline assembly feature. Suitable for Win32 Apps
 *  Also compatible with Microsoft Visual C++ 32-bit compiler
*/

#define ASM _asm

int muldiv(a,b,c,m,rp)
int a,b,c,m,*rp;
{
        ASM mov   eax,DWORD PTR a      
        ASM mul   DWORD PTR b          
        ASM add   eax,DWORD PTR c      
        ASM adc   edx,0h                 
        ASM div   DWORD PTR m          
        ASM mov   ebx,DWORD PTR rp     
        ASM mov   [ebx],edx              
}

int muldvm(a,c,m,rp)
int a,c,m,*rp;
{
        ASM mov   edx,DWORD PTR a      
        ASM mov   eax,DWORD PTR c      
        ASM div   DWORD PTR m          
        ASM mov   ebx,DWORD PTR rp     
        ASM mov   [ebx],edx              
}

int muldvd(a,b,c,rp)
int a,b,c,*rp;
{
        ASM mov   eax,DWORD PTR a      
        ASM mul   DWORD PTR b          
        ASM add   eax,DWORD PTR c      
        ASM adc   edx,0h                 
        ASM mov   ebx,DWORD PTR rp     
        ASM mov   [ebx],eax              
        ASM mov   eax,edx
}


void muldvd2(a,b,c,rp)
int a,b,*c,*rp;
{
        ASM mov   eax,DWORD PTR a      
        ASM mul   DWORD PTR b          
        ASM mov   ebx,DWORD PTR c
        ASM add   eax,[ebx]
        ASM adc   edx,0h
        ASM mov   esi,DWORD PTR rp
        ASM add   eax,[esi]
        ASM adc   edx,0h
        ASM mov   [esi],eax              
        ASM mov   [ebx],edx
}


/
/  Version for 32-bit Sun 386i Workstation
/
        .file   "mrmuldv.c"
        .version        "sun386-1.0"
        .text
        .globl  muldiv
muldiv:
        pushl   %ebp
        movl    %esp,%ebp

        movl    8(%ebp),%eax         /get a
        mull    12(%ebp)             /multiply by b
        addl    16(%ebp),%eax        /add c to low word
        adcl    $0,%edx              /add carry to high word

        divl    20(%ebp)             /divide by m 
        movl    24(%ebp),%ebx        /get address for remainder
        movl    %edx,(%ebx)          /store remainder

        popl    %ebp
        ret

        .text
        .globl  muldvm
muldvm:
        pushl   %ebp
        movl    %esp,%ebp

        movl    8(%ebp),%edx       /get a
        movl    12(%ebp),%eax      /add in c
        divl    16(%ebp)           /divide by m

        movl    20(%ebp),%ebx      /get address for remainder
        movl    %edx,(%ebx)        /store remainder

        popl    %ebp
        ret

        .text
        .globl  muldvd
muldvd:
        pushl   %ebp
        movl    %esp,%ebp

        movl    8(%ebp),%eax       /get a
        mull    12(%ebp)           /multiply by b
        addl    16(%ebp),%eax      /add c to low word
        adcl    $0,%edx            /add carry to high word
        movl    20(%ebp),%ebx      /get address for remainder
        movl    %eax,(%ebx)        /store remainder
        movl    %edx,%eax          /get quotient

        popl    %ebp
        ret

/
/ DJGPP GNU C version for DOS
/ M. Scott 22/3/98
/


        .file   "mrmuldv.c"
.text
.globl  _muldiv
_muldiv:
        pushl   %ebp
        movl    %esp,%ebp
        pushl   %ebx


        movl    8(%ebp),%eax  
        mull    12(%ebp)      
        addl    16(%ebp),%eax 
        adcl    $0,%edx       

        divl    20(%ebp)       
        movl    24(%ebp),%ebx 
        movl    %edx,(%ebx)
    
        popl    %ebx
        popl    %ebp
        ret

        .globl  _muldvm
_muldvm:
        pushl   %ebp
        movl    %esp,%ebp
        pushl   %ebx

        movl    8(%ebp),%edx  
        movl    12(%ebp),%eax 
        divl    16(%ebp)      

        movl    20(%ebp),%ebx 
        movl    %edx,(%ebx)   

        popl    %ebx
        popl    %ebp
        ret

        .globl  _muldvd
_muldvd:
        pushl   %ebp
        movl    %esp,%ebp
        pushl   %ebx

        movl    8(%ebp),%eax  
        mull    12(%ebp)      
        addl    16(%ebp),%eax 
        adcl    $0,%edx       
        movl    20(%ebp),%ebx 
        movl    %eax,(%ebx)   
        movl    %edx,%eax     

        popl    %ebx
        popl    %ebp
        ret

        .globl  _muldvd2
_muldvd2:
        pushl   %ebp
        movl    %esp,%ebp
        pushl   %ebx
        pushl   %esi

        movl    8(%ebp),%eax  
        mull    12(%ebp)
        movl    16(%ebp),%ebx
        addl    (%ebx),%eax
        adcl    $0,%edx       
        movl    20(%ebp),%esi
        addl    (%esi),%eax
        adcl    $0,%edx

        movl    %eax,(%esi)   
        movl    %edx,(%ebx)     

        popl    %esi
        popl    %ebx
        popl    %ebp
        ret

/
/ GNU C for Linux (and other 386 based Linux/Unix??) 
/
/

        .file   "mrmuldv.s"
.text
.globl  muldiv
muldiv:
        pushl   %ebp
        movl    %esp,%ebp
        pushl   %ebx


        movl    8(%ebp),%eax  
        mull    12(%ebp)      
        addl    16(%ebp),%eax 
        adcl    $0,%edx       

        divl    20(%ebp)       
        movl    24(%ebp),%ebx 
        movl    %edx,(%ebx)
    
        popl    %ebx
        popl    %ebp
        ret

        .globl  muldvm
muldvm:
        pushl   %ebp
        movl    %esp,%ebp
        pushl   %ebx

        movl    8(%ebp),%edx  
        movl    12(%ebp),%eax 
        divl    16(%ebp)      

        movl    20(%ebp),%ebx 
        movl    %edx,(%ebx)   

        popl    %ebx
        popl    %ebp
        ret

        .globl  muldvd
muldvd:
        pushl   %ebp
        movl    %esp,%ebp
        pushl   %ebx

        movl    8(%ebp),%eax  
        mull    12(%ebp)      
        addl    16(%ebp),%eax 
        adcl    $0,%edx       
        movl    20(%ebp),%ebx 
        movl    %eax,(%ebx)   
        movl    %edx,%eax     

        popl    %ebx
        popl    %ebp
        ret

        .globl  muldvd2
muldvd2:
        pushl   %ebp
        movl    %esp,%ebp
        pushl   %ebx
        pushl   %esi

        movl    8(%ebp),%eax  
        mull    12(%ebp)
        movl    16(%ebp),%ebx
        addl    (%ebx),%eax
        adcl    $0,%edx       
        movl    20(%ebp),%esi
        addl    (%esi),%eax
        adcl    $0,%edx

        movl    %eax,(%esi)   
        movl    %edx,(%ebx)     

        popl    %esi
        popl    %ebx
        popl    %ebp
        ret

;
;  Watcom C/386 32-bit compiler V7.0. Use with mirdef.h32
;  Most parameters passed in registers
;  Written for Phar Lap 386ASM macro-assembler
;
;   V4.0 NOTE! Inline assembly versions of these routines, 
;   are also available. See miracl.h for details
;

        .386
        ASSUME CS:_TEXT
_TEXT   SEGMENT BYTE PUBLIC 'CODE'

        PUBLIC muldiv_
muldiv_ PROC NEAR

        mul     edx                 ;multiply a*b
        add     eax,ebx             ;add in c
        adc     edx,0               ;carry
        div     ecx                 ;divide by m
        mov     ebx,[esp+4]
        mov     [ebx],edx           ;remainder
        ret     4                   ;quotient in eax

muldiv_ endP

        PUBLIC muldvm_
muldvm_ PROC NEAR

        xchg    eax,edx       ;a*base+c
        div     ebx           ;divide by m
        mov     [ecx],edx     ;store remainder
        ret                   ;quotient in eax

muldvm_ endP

        PUBLIC muldvd_
muldvd_ PROC NEAR

        mul     edx           ;multiply a*b
        add     eax,ebx       ;add in c
        adc     edx,0
        mov     [ecx],eax     ;store remainder
        mov     eax,edx       ;get quotient
        ret                   ;quotient in eax

muldvd_ endP

_TEXT   ENDS
END

;
;  Zortech C/386 32-bit compiler V2.1
;  Use with mirdef.h32
;  Written for Phar lap 386ASM macro-assembler
;

        .386
        ASSUME CS:_TEXT
_TEXT   SEGMENT BYTE PUBLIC 'CODE'

        PUBLIC _muldiv
_muldiv PROC NEAR

        mov     eax,DWORD PTR [esp+4]
        mul     DWORD PTR [esp+8]
        add     eax,DWORD PTR [esp+12]
        adc     edx,0         
        div     DWORD PTR [esp+16]
        mov     ebx,DWORD PTR [esp+20]
        mov     [ebx],edx         
        ret

_muldiv endP

        PUBLIC _muldvm
_muldvm PROC NEAR

        mov     edx,DWORD PTR [esp+4]
        mov     eax,DWORD PTR [esp+8]
        div     DWORD PTR [esp+12]
        mov     ebx,DWORD PTR [esp+16]
        mov     [ebx],edx
        ret              

_muldvm endP

        PUBLIC _muldvd
_muldvd PROC NEAR

        mov     eax,DWORD PTR [esp+4]
        mul     DWORD PTR [esp+8]
        add     eax,DWORD PTR [esp+12]
        adc     edx,0
        mov     ebx,DWORD PTR [esp+16]
        mov     [ebx],eax
        mov     eax,edx
        ret        

_muldvd endP

_TEXT   ENDS
END



unsigned int muldiv(a,b,c,m,rp)
unsigned int a,b,c,m,*rp;
{
    asm
    {
    ;
    ;  MACintosh version for Megamax or Lightspeed  Think C compiler
    ;  with 16-bit int, 68000 processor
    ;  For a 32 bit version for the 68020, see below 
    ;
        move   a(A6),D1      ;get a
        mulu   b(A6),D1      ;multiply by b
        clr.l  D0
        move   c(A6),D0      ;get c
        add.l  D0,D1         ;D1 contains a*b+c
        divu   m(A6),D1      ;divide by m
        move   D1,D0         ;return with quotient in D0
        swap   D1            ;get remainder
        move.l rp(A6),A0     ;get address for remainder
        move   D1,(A0)       ;store remainder
    }
}

unsigned int muldvm(a,c,m,rp)
unsigned int a,c,m,*rp;
{
    asm
    {
    ; 
    ; Version of muldvm for Apple MAC
    ;
        clr.l  D1
        move   a(A6),D1      ;get a
        swap   D1            ;move a to high word
        move   c(A6),D1      ;add in c
        divu   m(A6),D1      ;divide by m
        move   D1,D0         ;return quotient in D0
        swap   D1            ;get remainder
        move.l rp(A6),A0     ;get address for remainder
        move   D1,(A0)       ;store remainder
    }
}

unsigned int muldvd(a,b,c,rp)
unsigned int a,b,c,*rp;
{
    asm
    {
    ;
    ; Version of muldvd for Apple MAC
    ;
        move   a(A6),D1      ;get a
        mulu   b(a6),D1      ;multiply by b
        clr.l  D0
        move   c(A6),D0      ;get c
        add.l  D0,D1         ;add in c
        move.l D1,D0         
        swap   D0            ;return quotient in D0
        move.l rp(A6),A0     ;get address for remainder
        move   D1,(A0)       ;store remainder
    }
}

#
# 68020+ versions for Next, and for new 32-bit Macs
# Parameters come off the stack
#

.globl _muldiv,_muldvm,_muldvd

_muldiv:
    movel sp@(4),d0
    mulul sp@(8),d1:d0
    addl  sp@(12),d0
    negxl d1          # tricky stuff!
    negl  d1
    divul sp@(16),d1:d0
    movel sp@(20),a0
    movel d1,a0@
    rts

_muldvm:
    movel sp@(4),d1
    movel sp@(8),d0
    divul sp@(12),d1:d0
    movel sp@(16),a0
    movel d1,a0@
    rts

_muldvd:
    movel sp@(4),d1
    mulul sp@(8),d0:d1
    addl  sp@(12),d1
    negxl d0
    negl  d0
    movel sp@(16),a0
    movel d1,a0@
    rts


unsigned int muldiv(a,b,c,m,rp)
unsigned int a,b,c,m,*rp;
{
    asm
    {
    ;
    ; 32016 processor version for BBC Master Scientific
    ; with 32-bit int, by Dudley Long, Rutherford-Appleton Labs.
    ; No muldvm() or muldvd()
    ;
        movd   a,0           ;move a to R0
        meid   b,0           ;multiply  by b, result extended
        addd   c,0           ;add c to extended number in R0 & R1
        addcd  #0,1
        deid   m,0           ;divide by m
        movd   0,0(rp)       ;remainder to *rp
        movd   1,0           ;quotient returned in R0
    }
}

;
; Acorn ARM Risc version (32-bit) for Archimedes micro
; Wingpass Macro Assembler
; Use with mirdef.h32
;
.INCLUDE "A.REGNAMES"

.AREA C$$code, .CODE, .READONLY

muldiv::
         MOV     ip, sp             ;standard linkage
         STMFD   sp!, {v1-v4}

         CMPS    a2,#0x80000000     ;check for b=MAXBASE
         MOVEQ   v3,a1,LSL #31      ;this idea is quicker because
         MOVEQ   v4,a1,LSR #1       ;of ARM barrel shifting capability
         BEQ     addin
         MOV     v1,a1,LSR #16      ;do it the hard way
         MOV     v2,a2,LSR #16
         BIC     a1,a1,v1,LSL #16
         BIC     a2,a2,v2,LSL #16
         MUL     v3,a1,a2           ;form partial products of a*b
         MUL     v4,v1,v2
         SUB     v1,v1,a1
         SUB     v2,a2,v2
         MLA     v1,v2,v1,v3        ;look - only 3 MULs!
         ADD     v1,v1,v4
         ADDS    v3,v3,v1,LSL #16
         ADC     v4,v4,v1,LSR #16
addin:
         ADDS    v3,v3,a3           ;now add in c
         ADCCS   v4,v4,#0

         CMPS    a4,#0x80000000     ;check for m=MAXBASE
         MOVEQ   a1,v3,LSR #31
         ADDEQ   a1,a1,v4,LSL #1
         BICEQ   v4,v3,#0x80000000
         BEQ     leave
         MOV     a1,#0              ;do long division by m

divlp:

.REPEAT 32                          ;2xfaster than a loop!
         MOVS    v3,v3,ASL #1       ;get next bit into carry
         ADC     v4,v4,v4           ;accumulate remainder
         CMPS    v4,a4
         SUBCS   v4,v4,a4
         ADC     a1,a1,a1           ;accumulate quotient
.ENDREPEAT

leave:
         LDR     v3,[ip]
         STR     v4,[v3]       ;store remainder
         LDMFD   sp!, {v1-v4}
         MOVS pc,lr

muldvm::
         STMFD   sp!, {v1-v2}

         MOV     v2,a1              ;'multiply' by 2^32
         MOV     v1,a2              ;add in c

         MOV     a1,#0              ;do long division by m

.REPEAT 32                          ;2xfaster than a loop!
         MOVS    v1,v1,ASL #1       ;get next bit into carry
         ADCS    v2,v2,v2           ;accumulate remainder
         CMPCCS  v2,a3
         SUBCS   v2,v2,a3
         ADC     a1,a1,a1           ;accumulate quotient
.ENDREPEAT

         STR     v2,[a4]       ;store remainder
         LDMFD   sp!, {v1-v2}
         MOVS    pc,lr


muldvd::
         STMFD   sp!, {v1-v2}

         MOV     ip,a1,LSR #16      ;do it the hard way
         MOV     v2,a2,LSR #16
         BIC     a1,a1,ip,LSL #16
         BIC     a2,a2,v2,LSL #16
         MUL     v1,a1,a2           ;form partial products of a*b
         MUL     a2,ip,a2
         MUL     a1,v2,a1
         MUL     v2,ip,v2
         ADDS    a1,a2,a1
         ADDCS   v2,v2,#0x10000
         ADDS    v1,v1,a1,LSL #16
         ADC     v2,v2,a1,LSR #16
         
         ADDS    v1,v1,a3           ;now add in c
         ADCCS   v2,v2,#0
         MOV     a1,v2              ;get quotient

         STR     v1,[a4]            ;store remainder
         LDMFD   sp!, {v1-v2}
         MOVS    pc,lr

;
;  Version for Pyramid 90x and 98x computers
;  from Rod Worley, Monash University, Victoria, Australia
;
;  No muldvm() or muldvd()
;
        .text 0
        .globl _muldiv
_muldiv:
        movw    pr0,pr8             ;save a in reg 8
        movw    $0x0,pr0            ;zero reg0 so long reg 0,1 is b
        emul    pr8,pr0             ;extended multiply by a
        addw    pr2,pr1             ;add c to extended result
        addwc   $0x0,pr0         
        ediv    pr3,pr0             ;extended div by m
        movw    pr1,(pr4)           ;store remainder
        ret                         ;return qotient in pr0

/* This is the transputer version, by A.H. Pepperdine   */
/* Assumes that the result will fit into a 32-bit word  */
/* The error flag will be set if                        */
/*           (a*b+c)/m >= 2**32                         */
/* ie. equivalently, if                                 */
/*           ( (a*b+c) >> 32) >= m                      */

unsigned int muldiv(unsigned int a, unsigned int b, unsigned int c,
                    unsigned int m, unsigned int * rp)
{
    unsigned int q;
    __asm
    {
      ldabc a, b, c;
      lmul  ;
      ld    m;
      ldiv  ;
      stab  q, *rp;
    }
    return q;
}

/* The base is 2**32, ie a full 32-bit unsigned integer */
/* The error flag will be set if the result will not fit*/
/* into a word, ie.                                     */
/* for muldvm that is if (a >= m)                       */
/* and for muldvd it cannot happen                      */

unsigned int muldvm(unsigned int a, unsigned int c,
                    unsigned int m, unsigned int * rp)
{
    unsigned int q;
    __asm
    {
      ldabc m, c, a;
      ldiv ;
      stab q, *rp;
    }
    return q;
}

unsigned int muldvd(unsigned int a, unsigned int b, unsigned int c,
                    unsigned int * rp)
{
    unsigned int q;
    __asm
    {
      ldabc a, b, c;
      lmul ;
      stab *rp, q;
    }
    return q;
}

/*  Now ... just to confuse you even more ....

    Blakley/Sloan 'portable' method for Modular multiplication IEEE Trans 
    Computers C-34 March 1985 pp 290-292 eliminates need for double length 
    product - but will be slow. Might suit some RISC computers with no 
    multiply/divide instructions. To speed up try completely unravelling for() 
    loops.       
    
    This method should only be used if the mr_utype data type is twice the size 
    of a "mr_hltype" data-type. This must be defined below.

    Note: DON't define MR_NOASM in mirdef.h if using this method.

    */ 

#include <stdio.h>
#include <miracl.h>

mr_small muldiv(a,b,c,m,rp)
mr_small a,b,c,m;
mr_small *rp;
{
    int i;
    mr_small d,q=0,r=0;
    d=m-a;
    for (i=MIRACL/4;i>0;i--)
    { /* do it bit by bit */
        r<<=1;
        if ((mr_utype)c<0) r++;
        c<<=1;
        q<<=1;
        if ((mr_utype)b<0)
        {
            if (r>=m) { r-=d; q++; }
            else        r+=a;
        }
        if (r>=m) { r-=m; q++; }
        b<<=1;
        r<<=1;
        if ((mr_utype)c<0) r++;
        c<<=1;
        q<<=1;
        if ((mr_utype)b<0)
        {
            if (r>=m) { r-=d; q++; }
            else        r+=a;
        }
        if (r>=m) { r-=m; q++; }
        b<<=1;
        r<<=1;
        if ((mr_utype)c<0) r++;
        c<<=1;
        q<<=1;
        if ((mr_utype)b<0)
        {
            if (r>=m) { r-=d; q++; }
            else        r+=a;
        }
        if (r>=m) { r-=m; q++; }
        b<<=1;
        r<<=1;
        if ((mr_utype)c<0) r++;
        c<<=1;
        q<<=1;
        if ((mr_utype)b<0)
        {
            if (r>=m) { r-=d; q++; }
            else        r+=a;
        }
        if (r>=m) { r-=m; q++; }
        b<<=1;
    }
    *rp=r;
    return q;
}

mr_small muldvm(a,c,m,rp)
mr_small a,c,m;
mr_small *rp;
{ /* modified Blakely-Sloan */
    register int i,carry;
    register mr_small q=0,r=0;
    r=a;
    for (i=MIRACL/4;i>0;i--)
    { /* do it bit by bit */
        carry=0;
        if ((mr_utype)r<0) carry=1;
        r<<=1;
        if ((mr_utype)c<0) r++;
        c<<=1;
        q<<=1;
        if (carry || r>=m) { r-=m; q++; }
        carry=0;
        if ((mr_utype)r<0) carry=1;
        r<<=1;
        if ((mr_utype)c<0) r++;
        c<<=1;
        q<<=1;
        if (carry || r>=m) { r-=m; q++; }
        carry=0;
        if ((mr_utype)r<0) carry=1;
        r<<=1;
        if ((mr_utype)c<0) r++;
        c<<=1;
        q<<=1;
        if (carry || r>=m) { r-=m; q++; }
        carry=0;
        if ((mr_utype)r<0) carry=1;
        r<<=1;
        if ((mr_utype)c<0) r++;
        c<<=1;
        q<<=1;
        if (carry || r>=m) { r-=m; q++; }
    }
    *rp=r;
    return q;
}

/* define mr_hltype as that C type that is half the size in bits of the 
   underlying type (mr_utype in mirdef.h). Perhaps short if mr_utype is long? */

#define mr_hltype short

mr_small muldvd(a,b,c,rp)
mr_small a,b,c;
mr_small *rp;
{ /* multiply by parts */
    mr_small middle,middle2;
    mr_small q,r;
    unsigned mr_hltype am,al,bm,bl;
    int hshift=(MIRACL>>1);
    am=(unsigned mr_hltype)(a>>hshift);
    al=(unsigned mr_hltype)a;
    bm=(unsigned mr_hltype)(b>>hshift);
    bl=(unsigned mr_hltype)b;
/* form partial products */
    r= (mr_small)al*bl;  
    q= (mr_small)am*bm;
    middle=(mr_small)al*bm;
    middle2=(mr_small)bl*am;
    middle+=middle2;                        /* combine them - carefully */
    if (middle<middle2) q+=((mr_small)1<<hshift);
    r+=(middle << hshift);
    if ((r>>hshift)<(unsigned mr_hltype)middle) q++;
    q+=(middle>>hshift);
    r+=c;
    if (r<c) q++;
    *rp=r;
    return q;
}   


/* SPARC assembler version of above. Note that when Full-width base 
   working is used, then muldvd() is the most time-critical of these
   three routines. Use with above Blakely-Sloan C versions of muldvm 
   and muldiv (Assumes mr_utype is 32 bit int) */
          .global _muldvd
_muldvd:
          mov    %o1,%y       ;multiplier to y register
          andcc  %g0,%g0,%o4  ;zero partial product and clear flags
          nop                 ;twiddle thumbs while write 
          nop                 ;to %y register completes
          mulscc %o4,%o0,%o4  ;1 multiply a*b
          mulscc %o4,%o0,%o4  ;2
          mulscc %o4,%o0,%o4  ;3
          mulscc %o4,%o0,%o4  ;4
          mulscc %o4,%o0,%o4  ;5
          mulscc %o4,%o0,%o4  ;6
          mulscc %o4,%o0,%o4  ;7
          mulscc %o4,%o0,%o4  ;8
          mulscc %o4,%o0,%o4  ;9
          mulscc %o4,%o0,%o4  ;10
          mulscc %o4,%o0,%o4  ;11
          mulscc %o4,%o0,%o4  ;12
          mulscc %o4,%o0,%o4  ;13
          mulscc %o4,%o0,%o4  ;14
          mulscc %o4,%o0,%o4  ;15
          mulscc %o4,%o0,%o4  ;16
          mulscc %o4,%o0,%o4  ;17
          mulscc %o4,%o0,%o4  ;18
          mulscc %o4,%o0,%o4  ;19
          mulscc %o4,%o0,%o4  ;20
          mulscc %o4,%o0,%o4  ;21
          mulscc %o4,%o0,%o4  ;22
          mulscc %o4,%o0,%o4  ;23
          mulscc %o4,%o0,%o4  ;24
          mulscc %o4,%o0,%o4  ;25
          mulscc %o4,%o0,%o4  ;26
          mulscc %o4,%o0,%o4  ;27
          mulscc %o4,%o0,%o4  ;28
          mulscc %o4,%o0,%o4  ;29
          mulscc %o4,%o0,%o4  ;30
          mulscc %o4,%o0,%o4  ;31
          mulscc %o4,%o0,%o4  ;32
          mulscc %o4,%g0,%o4
          tst    %o0          ;adjust result
          bge 1f
          nop
          add    %o4,%o1,%o4
1:
          rd     %y,%o1       ;get LSBs
          addcc  %o1,%o2,%o1  ;add in c
          st     %o1,[%o3]    ;store remainder
          retl          
          addxcc %o4,%g0,%o0  ;delay slot - return quotient
*/


/* If you have a "decent" SPARC which supports UMUL and UDIV instructions
   then the following will be much faster. Cut and paste what follows 
   into mrmuldv.s. See miracl.mak make file 

   Aside: God, I hate the Sparc, with its slippery ill-defined Instruction 
          set. Not all implementations support UMUL and UDIV, so its safer 
          to use the method above. 

   Note: Sometimes the routine name needs a preceding underscore,
         so it may be necessary to change for example muldvd to _muldvd
         through-out. Depends on the Unix version
*/

          .global muldvd
muldvd:
          umul   %o0,%o1,%o0              
          rd     %y,%o1       
          addcc  %o0,%o2,%o0  
          st     %o0,[%o3]    
          retl          
          addx   %o1,%g0,%o0 

          .global muldvd2
muldvd2:
          umul   %o0,%o1,%o0              
          rd     %y,%o1   
          ld     [%o2],%o5
          addcc  %o0,%o5,%o0 
          ld     [%o3],%o5
          addx   %o1,%g0,%o1
          addcc  %o0,%o5,%o0 
          st     %o0,[%o3]    
          addx   %o1,%g0,%o1 
          retl          
          st     %o1,[%o2]

         .global muldvm
muldvm:
          mov %o0,%y
          nop
          nop
          nop
          udiv %o1,%o2,%o0
          umul %o0,%o2,%o2
          sub  %o1,%o2,%o1
          retl
          st  %o1,[%o3]
          
          .global muldiv
muldiv:
           umul  %o0,%o1,%o1
           rd    %y,%o0
           addcc %o1,%o2,%o1
           addx  %o0,%g0,%o0
           mov %o0,%y
           nop
           nop
           nop
           udiv %o1,%o3,%o0
           umul %o0,%o3,%o2
           sub  %o1,%o2,%o1
           retl
           st %o1,[%o4]


/* before leaving the SPARC, here is an interesting idea
   Specify the underlying type as the 64-bit long long, as supported by the
   GCC compiler. Use the Blakely-Sloan Portable Code above, with mr_hltype
   defined as a long. This has been tried and works, getting 64-bit 
   behaviour from a 32-bit processor! Its slower than the 32-bit code above,
   but if the 64-bit mrmuldvd() were rewritten in fast assembler.....? */ 

#########################################################################################
#
# mrmuldv.s
# author: G. Garth Feb 1996
# 
# implementation of modular multiplication for smalls
# using Blakely-Sloan division algorithm
# for Motorola 601 and 604 RISC PowerPC 32-bit processors
# see IEEE trans. Computers C-34, No. 3, March 1985 pp. 290-292
#
# see also PowerPC Microprocessor Developer's guide
# by Bunda, Potter & Shadowen, SAMS 1995, Appendix A p. 177
#
# intended for use in MIRACL library as assembly language implementation
# of routines muldiv, muldvm and muldvd
# written for Apple MPW PPC Assembler for Macintosh PPC computers
#
# Division Algorithm Pseudo Code
# given: integers A,B,C,D and M where D = A * B + C
# this algorithm computes Q and R such that
# D = M * Q + R
# Constraints:
# A,B,C,M < 2^H where H is word length in bits 
# 0 <= Q,R < M; 0 < D < 2^(2*H)
# 
# let K = # of bits in D
#
# R = Q = 0;
# for(T = K - 1; T >= 0; T--)
# {
#       R <<= 1;
#       Q <<= 1;
#       if(D[T] == 1)
#       {
#               R += 1;
#       }
#       while(R >= M)
#       {
#               R -= M;
#               Q += 1;
#       }
# }
#
#########################################################################################

        export muldiv[DS]
        export .muldiv[PR]
        export muldvm[DS]
        export .muldvm[PR]
        export muldvd[DS]
        export .muldvd[PR]

        toc
                tc muldiv[TC],muldiv[DS]
                tc muldvm[TC],muldvm[DS]
                tc muldvd[TC],muldvd[DS]
        
        csect muldiv[DS]
                dc.l .muldiv[PR]
                dc.l TOC[tc0]
        csect muldvm[DS]
                dc.l .muldvm[PR]
                dc.l TOC[tc0]
        csect muldvd[DS]
                dc.l .muldvd[PR]
                dc.l TOC[tc0]
                
#
# unsigned int muldiv(a,b,c,m,rp)
# unsigned int a,b,c,m,*rp;
# returns q = int[(a*b+c)/m] and *rp = (a*b+c) mod m
# when called a -> (r3), b -> (r4), c -> (r5), m -> (r6), rp -> (r7)
# upon return q -> (r3), *rp -> [(r12)]
# registers used: r3 thru r12
#

        csect .muldiv[PR]
        function .muldiv[PR]
        
        or r12,r7,r7           ;(r12) <- remainder address
        mulhwu r8,r3,r4        ;(r8) <- a * b  high word
        mullw r9,r3,r4         ;(r9 ) <- a * b  low word
        addc r4,r5,r9          ;(r4) <- a * b + c  dividend.lo
        addze r3,r8            ;(r3) <- (r8) + XERca  dividend.hi
        subic. r5,r3,0         ;test for zero dividend.hi
        bne divlong            ;
                               ;here if dividend is single word
        divwu r3,r4,r6         ;(r3) <- quotient
        mullw r7,r6,r3;        ;(r7) <- r6 * int (r4 / r6)
        subf r5,r7,r4          ;(r5) <- remainder.lo
        stw r5,0x0000(r12)     ;[(r12)] <- remainder
        blr                    ;that's all for single word division
                               
divlong:
        xor r7,r7,r7           ;zero divisor.hi
        nor r7,r7,r7           ;calc ~divisor.hi
        subfic r8,r6,0         ;(r8) <- -divisor.lo, set CA
        addze r7,r7            ;(r7) <- ~divisor.hi + CA
        or r11,r4,r4           ;(r11) <- dividend.lo
        or r4,r3,r3            ;(r4) <- dividend.hi
                               ;try to shift ahead, skipping unnecessary
                               ;shifting loops
        cntlzw r10,r4          ;find order of dividend.hi
        subfic r9,r10,32       ;calc shift = 32 - order
        slw r4,r4,r10          ;shift ahead dividend.hi
        srw r3,r11,r9          ;get shifted part of dividend.lo
        or r4,r4,r3            ;combine with dividend.hi
        slw r11,r11,r10        ;shift ahead dividend.lo
        addi r9,r9,33          ;setup for looping
        mtctr r9               ;
        xor r3,r3,r3           ;clear quotient.lo
        xor r5,r5,r5           ;clear shift.hi
        xor r6,r6,r6           ;clear shift.lo
        b ldiff                ;skip first round of shifting
        align 6                ;align loop to 64-byte boundary
lshift:
        rlwinm r5,r5,1,0,30    ;shift.hi <<= 1
        rlwimi r5,r6,1,31,31   ;shift.hi[31] = shift.lo[0]
        rlwinm r6,r6,1,0,30    ;shift.lo <<= 1
        rlwimi r6,r4,1,31,31   ;shift.lo[31] = dividend.hi[0]
        rlwinm r4,r4,1,0,30    ;dividend.hi <<= 1
        rlwimi r4,r11,1,31,31  ;dividend.hi[31] = dividend.lo[0]
        rlwinm r11,r11,1,0,30  ;dividend.lo <<= 1
        rlwinm r3,r3,1,0,30    ;quotient.lo <<=1
ldiff:
        addc r10,r6,r8         ;diff.lo = shift.lo - divisor.lo, set CA
        adde. r9,r5,r7         ;diff.hi = shift.hi - divisor.hi + CA
        blt lloop              ;loop if diff < 0
        or r6,r10,r10          ;shift.lo = diff.lo
        or r5,r9,r9            ;shift.hi = diff.hi
        ori r3,r3,1            ;set bit in quotient
lloop:
        bdnz lshift             ;loop until done
        stw r6,0x0000(r12)     ;store remainder in rp address
        blr                    ;return  

#
# unsigned int muldvm(a,c,m,rp)
# unsigned int a,c,m,*rp;
# returns q = int[(a*base+c)/m] and *rp = (a*base+c) mod m
# when called a -> (r3), c -> (r4), m -> (r5), rp -> (r6)
# upon return q -> (r3), *rp -> [(r12)]
# registers used: r3 thru r12 
#

        csect .muldvm[PR]
        function .muldvm[PR]
        
        or r12,r6,r6           ;(r12) <- remainder address
        or r6,r5,r5            ;(r6) <- m
        xor r7,r7,r7           ;zero divisor.hi
        nor r7,r7,r7           ;calc ~divisor.hi
        subfic r8,r6,0         ;(r8) <- calc -divisor.lo, set CA
        addze r7,r7            ;(r7) <- ~divisor.hi += CA
        or r11,r4,r4           ;(r11) <- dividend.lo
        or r4,r3,r3            ;(r4) <- dividend.hi
                               ;try to shift ahead, skipping unnecessary
                               ;shifting loops
        cntlzw r10,r4          ;find order of dividend.hi
        subfic r9,r10,32       ;calc shift = 32 - order
        slw r4,r4,r10          ;shift ahead dividend.hi
        srw r3,r11,r9          ;get shifted part of dividend.lo
        or r4,r4,r3            ;combine with dividend.hi
        slw r11,r11,r10        ;shift ahead dividend.lo
        addi r9,r9,33          ;setup for looping
        mtctr r9               ;
        xor r3,r3,r3           ;clear quotient.lo
        xor r5,r5,r5           ;clear shift.hi
        xor r6,r6,r6           ;clear shift.lo
        b sdiff                ;skip first round of shifting
        align 6                ;align loop to 64-byte boundary
sshift:
        rlwinm r5,r5,1,0,30    ;shift.hi <<= 1
        rlwimi r5,r6,1,31,31   ;shift.hi[31] = shift.lo[0]
        rlwinm r6,r6,1,0,30    ;shift.lo <<= 1
        rlwimi r6,r4,1,31,31   ;shift.lo[31] = dividend.hi[0]
        rlwinm r4,r4,1,0,30    ;dividend.hi <<= 1
        rlwimi r4,r11,1,31,31  ;dividend.hi[31] = dividend.lo[0]
        rlwinm r11,r11,1,0,30  ;dividend.lo <<= 1
        rlwinm r3,r3,1,0,30    ;quotient.lo <<=1
sdiff:
        addc r10,r6,r8         ;diff.lo = shift.lo - divisor.lo, set CA
        adde. r9,r5,r7         ;diff.hi = shift.hi - divisor.hi + CA
        blt sloop              ;loop if diff < 0
        or r6,r10,r10          ;shift.lo = diff.lo
        or r5,r9,r9            ;shift.hi = diff.hi
        ori r3,r3,1            ;set bit in quotient
sloop:
        bdnz sshift
        stw r6,0x0000(r12)     ;store remainder in rp address
        blr                    ;return  

#
# unsigned int muldvd(a,b,c,rp)
# unsigned int a,b,c,*rp;
# returns q = int[(a*b+c)/base] and *rp = (a*b+c) mod base
# when called a -> (r3), b -> (r4), c -> (r5), rp -> (r6)
# upon return q -> (r3), *rp -> [(r6)]
# registers used: r3 thru r8
#

        csect .muldvd[PR]
        function .muldvd[PR]
                               
        mulhwu r7,r3,r4        ;(r7) <- a * b  high word
        mullw r8,r3,r4         ;(r8) <- a * b  low word
        addc r4,r8,r5          ;(r4) <- a * b + c
        addze r3,r7            ;(r3) <- (r7) + XERca
        stw r4,0x0000(r6)      ;store remainder -> (r6)
        blr                    ;return
        


