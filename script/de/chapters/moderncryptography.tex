% $Id$
% !Mode:: "TeX:DE"    % Setting document mode and submode for WinEdt
% ..........................................................................
%         Die mathematischen Ideen hinter der modernen Kryptographie
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% be_2016-07-13: Housekeeping: " \\\" --> "\\" done (d+E).

\begin{refsegment}


\setcounter{satz}{0}
\setcounter{definition}{0}




\newpage
%********************************************************************
\hypertarget{Chapter_ModernCryptography}{}
\chapter[Die mathematischen Ideen hinter der modernen Kryptographie]
        {Die mathematischen Ideen hinter der modernen Kryptographie\footnotemark}
\chaptermark{Mathematische Ideen}
\footnotetext{%
    \index{ZT, Lernprogramm Zahlentheorie}%
    \index{Lernprogramm ZT}%
    Mit dem Lernprogramm \textbf{ZT} können Sie spielerisch einige der hier
    besprochenen Verfahren (RSA, Rabin, DH, ElGamal) nachvollziehen
    (siehe Lern-Kapitel 4.2 und 4.3, Seite 9-17/17).\\
    ZT können Sie in CT1\index{CT1} über das Menü
    \textbf{Einzelverfahren \textbackslash{} Zahlentheorie
    interaktiv \textbackslash{} Lernprogramm für Zahlentheorie} aufrufen.
    Siehe Anhang \ref{s:appendix-Learn-NT}.\\
    Entsprechende Funktionen finden Sie auch in den Programmen CT1,
    CT2\index{CT2} und JCT\index{JCT}: siehe die Liste der darin
    enthaltenen Funktionen in Anhang \ref{s:appendix-menu-overview-CT1},
    \ref{s:appendix-template-overview-CT2} und
    \ref{s:appendix-function-overview-JCT}.
}
\label{Chapter_ModernCryptography}
%********************************************************************
(\hyperlink{author_Roger-Oyono}{Roger Oyono} /
 \hyperlink{author_Bernhard-Esslinger}{Bernhard Esslinger} /
 \hyperlink{author_Joerg-Cornelius-Schneider}{Jörg-Cornelius Schneider},
 Sep. 2000;
 Updates: Nov. 2000, Feb. 2003, Apr. 2007, März 2010, Jan. 2013)

\begin{ctsquote}
   Ich weiß nicht, ob es besser wird, wenn wir es ändern,\\
   aber ich weiß, dass wir es ändern müssen, wenn es besser werden soll.\\
   {\em Anmerkung von Unbekannt (Radio) dazu:}\\
   Und Gott gebe den Akteuren bei der notwendigen Umsetzung\\
   das Wissen, die Weisheit und das Verantwortungsbewusstsein,\\
   zwischen Aktionismus, Selbstdarstellung und planvollem Handeln\\
   zu unterscheiden -- und ihr Wissen auch anzuwenden.
\caption[Georg Christoph Lichtenberg]{Georg Christoph Lichtenberg\footnotemark}
\end{ctsquote}
\footnotetext{%
  Georg Christoph Lichtenberg\index{Lichtenberg, Georg Christoph},
  deutscher Schriftsteller und Physiker (1742-1799),\\
  (siehe auch: \url{http://de.wikipedia.org/wiki/Georg\_Christoph\_Lichtenberg})
}

%--------------------------------------------------------------------
\hypertarget{OneWayFunktion1}{}
\section{Einwegfunktionen mit Falltür und Komplexitätsklassen}
\label{OneWayFunktion1}
%--------------------------------------------------------------------
\index{Kryptographie!modern} \index{Einwegfunktion}
Eine \textbf{Einwegfunktion} ist eine effizient zu
berechnende Funktion, deren Umkehrung jedoch nur mit
extrem hohem Rechenaufwand -- jedoch praktisch unmöglich -- zu berechnen ist.\par

Etwas genauer formuliert:  Eine Einwegfunktion ist eine Abbildung $ f $ einer Menge $ X $ in eine Menge $ Y, $ so dass $ f(x) $ für jedes Element $ x $ von $ X $ leicht zu berechnen ist, während es für (fast) jedes $ y $ aus $ Y $  praktisch unmöglich ist, ein Urbild $ x $ (d.h. ein $ x $ mit $ f(x)=y $) zu finden.\par

Ein alltägliches Beispiel für eine Einwegfunktion ist ein Telefonbuch: die auszuführende Funktion ist die, einem Namen die entsprechende Telefonnummer zuzuordnen. Da die Namen alphabetisch geordnet sind, ist diese Zuordnung einfach auszuführen. Aber ihre Invertierung, also die Zuordnung eines Namens zu einer gegebenen Nummer, ist offensichtlich schwierig, wenn man nur ein Telefonbuch zur Verfügung hat. \par

Einwegfunktionen spielen in der Kryptographie eine entscheidende Rolle. Fast alle kryptographischen Begriffe kann man durch Verwendung des Begriffs Einwegfunktion umformulieren. Als Beispiel betrachten wir die Public-Key-Verschlüsselung \index{Verschlüsselung!Public-Key} (asymmetrische Kryptographie):\par

Jedem Teilnehmer $ T $ des Systems wird ein privater \index{Schlüssel!privat}
\index{Schlüssel!öffentlich} Schlüssel $d_T$~\mbox{und} ein sogenannter öffentlicher
Schlüssel $ e_T $ zugeordnet. Dabei muss die folgende Eigenschaft (Public-Key-Eigen"-schaft)
gelten:\\
Für einen Gegner, der den öffentlichen Schlüssel $ e_T $ kennt, ist es praktisch unmöglich,
den privaten Schlüssel  $ d_T $ zu bestimmen.\par

Zur Konstruktion nützlicher Public-Key-Verfahren sucht man also eine Einwegfunktion, die in einer Richtung \glqq einfach\grqq {} zu berechnen, die in der anderen Richtung jedoch \glqq schwer\grqq {} (praktisch unmöglich) zu berechnen ist, solange eine bestimmte zusätzliche Information \index{Einwegfunktion!mit Falltür} (Falltür) nicht zur Verfügung steht. Mit der zusätzlichen Information kann die Umkehrung effizient gelöst werden. Solche Funktionen nennt man \textbf{Einwegfunktionen mit Falltür} (trapdoor one-way function). Im obigen Fall ist die Einwegfunktion die Verschlüsselung durch Potenzieren mit dem öffentlichen Schl\"ussel $e_T$ (als Exponent). Der geheime Schlüssel $ d_T $ ist die Falltür-In"-for"-ma"-tion.\par

Dabei bezeichnet man ein Problem als \glqq einfach\grqq, wenn es in \index{Laufzeit!polynomial} \index{Polynom} polynomialer Zeit als Funktion der Länge der Eingabe lösbar ist, d.h. wenn es so gelöst werden kann, dass der Zeitaufwand sich als polynomiale Funktion in Abhängigkeit der Länge der Eingabe darstellen lässt.
Wenn die Länge der Eingabe $ n $ Bits beträgt, so ist die Zeit der Berechnung der Funktion proportional zu $ n^{a}, $ wobei $ a $  eine Konstante ist. Man sagt, dass die \index{Komplexität} Komplexität solcher Probleme $ O(n^{a}) $ beträgt (Landau- oder Big-O-Notation).

Vergleicht man 2 Funktionen  $ 2^n $  und   $ n^{a} $, wobei $ a $
eine Konstante ist, dann gibt es immer einen Wert für  $ n $, ab dem
für alle weiteren $ n $ gilt: $ n^{a}  <  2^n $.
Die Funktion  $ n^{a} $  hat eine geringere Komplexität.
Z.B. für $ a=5 $ gilt: ab der Länge $ n=23 $ ist
$ 2^n > n^5 $ ~\mbox{und} danach wächst $ 2^n $ auch deutlich
schneller \
[($ 2^{22}= 4.194.304 $, $ 22^5= 5.153.632 $), \
 ($ 2^{23}= 8.388.608 $, $ 23^5= 6.436.343 $), \
 ($ 2^{24}=16.777.216 $, $ 24^5= 7.962.624 $)].\par
% "\mbox" nur, weil bei Ausdruck bei be die Blanks stets falsch saßen:
%  "n^5un d"

Der Begriff \glqq praktisch unmöglich\grqq {} ist etwas schwammiger.
Allgemein kann man sagen, ein Problem ist \index{Laufzeit!effizient}
nicht effizient lösbar, wenn der zu seiner Lösung benötigte Aufwand
schneller wächst als die polynomiale \index{Polynom} Zeit als Funktion der Größe der
Eingabe. Wenn beispielsweise die Länge der Eingabe $ n $  Bits beträgt
und die Zeit zur Berechnung der Funktion proportional zu $ 2^n $ ist,
so gilt gegenwärtig: die Funktion ist für $n > 80$ praktisch nicht zu
berechnen.

Die Entwicklung eines praktisch einsetzbaren Public-Key-Verfahrens hängt daher von der Entdeckung einer geeigneten Einwegfunktion mit Falltür ab.\par

Um Ordnung in die verwirrende Vielfalt von möglichen Problemen und ihre Komplexitäten zu bringen, fasst man Probleme mit ähnlicher Komplexität zu Klassen zusammen.

Die wichtigsten Komplexitätsklassen  sind die Klassen \textbf{P} und \textbf{NP}:

\begin{itemize}
    \item Die Klasse \textbf{P}: Zu dieser Klasse gehören diejenigen Probleme, die mit polynomialem \index{Polynom} Zeit"-auf"-wand lösbar sind.

    \item Die Klasse \textbf{NP}: Bei der Definition dieser Klasse betrachten wir nicht den Aufwand zur Lösung eines Problems, sondern den Aufwand zur Verifizierung einer gegebenen Lösung. Die Klasse \textbf{NP} besteht aus denjenigen Problemen, bei denen die Verifizierung einer gegebenen Lösung mit polynomialem Zeitaufwand möglich ist. Dabei bedeutet der Begriff \textbf{NP} \glqq nichtdeterministisch\grqq {} polynomial \index{Polynom} und bezieht sich auf ein Berechnungsmodell, d.h. auf einen nur in der Theorie existierenden Computer, der richtige Lösungen nichtdeterministisch \glqq raten\grqq {} und dies dann in polynomialer Zeit verifizieren kann.
\end{itemize}

Die Klasse \textbf{P} ist in der Klasse \textbf{NP} enthalten. Ein berühmtes offenes Problem ist die Frage, ob $ \textbf{P} \neq \textbf{NP} $ gilt oder nicht, d.h. ob \textbf{P} eine echte Teilmenge ist oder nicht. Eine wichtige Eigenschaft der Klasse \textbf{NP} ist, dass sie auch sogenannte \textbf{NP}-vollständige{} Probleme enthält. Dies sind Probleme, welche die Klasse \textbf{NP} in folgender Weise vollständig repräsentieren: Wenn es einen \glqq guten\grqq {} Algorithmus für ein solches Problem gibt, dann existieren für alle Probleme aus \textbf{NP} \glqq gute\grqq {} Algorithmen. Insbesondere gilt: Wenn auch nur ein vollständiges Problem in \textbf{P} läge, d.h. wenn es einen polynomialen \index{Polynom} Lösungsalgorithmus für dieses Problem gäbe, so wäre \textbf{P}=\textbf{NP}. In diesem Sinn sind die \textbf{NP}-vollständigen Probleme die schwierigsten Probleme in \textbf{NP}.

Viele kryptographische Protokolle sind so gemacht, dass die \glqq guten\grqq {} Teilnehmer nur Probleme aus \textbf{P} lösen müssen, während sich ein Angreifer vor Probleme aus \textbf{NP} gestellt sieht.

Man weiß leider bis heute nicht, ob es Einwegfunktionen überhaupt gibt. Man kann aber zeigen, dass Einwegfunktionen genau dann existieren, wenn $ \textbf{P} \neq \textbf{NP} $ gilt \cite[S.63]{Balcazar1988}.
\vskip +5pt

Immer wieder behauptete jemand, er habe die Äquivalenz bewiesen
(siehe \cite{Hesselink2001}), %%Hinweis wegen geocities per he.pa, 16.2.2010
aber bisher erwiesen sich diese Aussagen stets als falsch.

Es wurden eine Reihe von Algorithmen für Public-Key-Verfahren vorgeschlagen. Einige davon erwiesen sich, obwohl sie zunächst vielversprechend erschienen, als polynomial \index{Polynom} lösbar. Der berühmteste durchgefallene Bewerber ist der von Ralph Merkle \cite{Merkle1978} vorgeschlagene Knapsack mit Falltür.


%\newpage
\vskip +20 pt
%--------------------------------------------------------------------
\section{Knapsackproblem als Basis für Public-Key-Verfahren}
\index{Kryptographie!Public-Key}
%--------------------------------------------------------------------

%--------------------------------------------------------------------
\subsection{Knapsackproblem} \index{Knapsack}

Gegeben $ n $ Gegenstände $ G_1, \dots, G_n $ mit den Gewichten $ g_1, \dots g_n $ und den Werten $w_1, \cdots, w_n. $ Man soll wertmäßig so viel wie möglich unter Beachtung einer oberen Gewichtsschranke $ g $ davontragen. Gesucht ist also eine Teilmenge von $ \{ G_1, \cdots,G_n\}, $ etwa $ \{G_{i_1}, \dots ,G_{i_k} \}, $ so dass  $ w_{i_1}+ \cdots +w_{i_k} $ maximal wird unter der Bedingung $  g_{i_1}+ \cdots +g_{i_k} \leq g. $ \par
Derartige Fragen gehören zu den \textbf{NP}-vollständige Problemen (nicht \index{Laufzeit!nicht polynomial NP} deterministisch polynomial\index{Polynom}), die aufwendig zu berechnen sind.\index{Knapsack}

Ein Spezialfall des Knapsackproblems ist:\\
Gegeben sind die natürlichen Zahlen $ a_1, \dots, a_n $   und $ g .$
Gesucht sind  $ x_1, \dots, x_n \in \{ 0,1\} $  mit $ g = \sum_{i=1}^{n}x_i a_i $  (wo also $ g_i = a_i = w_i $ gewählt ist).
Dieses Problem heißt auch  \textbf{0-1-Knapsackprob"-lem} und wird mit $ K(a_1, \dots, a_n;g) $  bezeichnet.\\

Zwei 0-1-Knapsackprobleme  $ K(a_1, \dots, a_n;g) $   und
$ K(a'_1, \dots, a'_n;g') $  heißen kongruent, falls es zwei
teilerfremde\index{Zahlen!teilerfremd (co-prime)} Zahlen $ w $ und $ m $
gibt, so dass
\begin{enumerate}
    \item $ m > \max \{ \sum_{i=1}^n a_i , \sum_{i=1}^n a'_i \}, $

    \item $ g \equiv wg' \mod m, $

    \item $ a_i \equiv w a'_i \mod m $ für alle $ i=1, \dots, n.$

\end{enumerate}

\begin{remark}{:}\\
Kongruente 0-1-Knapsackprobleme haben dieselben Lösungen.
Ein schneller Algorithmus zur Klärung der Frage, ob zwei 0-1-Knapsackprobleme kongruent sind, ist nicht bekannt.
\end{remark}

Das Lösen eines 0-1-Knapsackproblems kann durch Probieren der $ 2^n $   Möglichkeiten für $ x_1, \dots, x_n $   erfolgen. Die beste Methode erfordert $ O(2^{n/2}) $  Operationen, was für $ n=100 $  mit $ 2^{100} \approx 1,27 \cdot 10^{30} $  und  $ 2^{n/2} \approx 1,13 \cdot 10^{15} $ für Computer eine unüberwindbare Hürde darstellt.
Allerdings ist die Lösung für spezielle $ a_1, \dots, a_n $   recht einfach zu finden, etwa für $ a_i = 2^{i-1}. $  Die binäre Darstellung von $ g $ liefert unmittelbar $ x_1, \dots, x_n$. Allgemein ist die Lösung des 0-1-Knapsackproblems leicht zu finden, falls eine \index{Permutation} Permutation\footnote{%
  Eine Permutation\index{Permutation} $\pi$ der Zahlen $1, \dots, n$ ist die
  Vertauschung der Reihenfolge, in der diese Zahlen aufgezählt werden.
  Beispielsweise ist eine Permutation $\pi$ von $(1,2,3)$ gleich $(3,1,2)$,
  also $\pi(1) = 3$, $\pi(2) = 1$ und $\pi(3) = 2$.
}
$ \pi $  von $ 1, \dots, n $  mit $ a_{\pi (j)} > \sum_{i=1}^{j-1} a_{\pi(i)} $
mit $ j =  1, \dots, n $ existiert.
Ist zusätzlich $ \pi $ die Identität, d.h. $ \pi(i)=i $ für $ i=1,2,\dots,n, $ so heißt die Folge $ a_1, \dots , a_n $ superwachsend.
Das Verfahren \ref{knapsackalgo} löst das Knapsackproblem mit superwachsender Folge im Zeitraum von $ O(n). $
\begin{cryptoprocedure}
\begin{tabbing}
\hspace*{0.5cm} \= \hspace*{0.5cm} \= \hspace*{0.5cm} \= \kill
\>\textbf{for} $ i=n $ \textbf{to} 1 \textbf{do}\\
\>\> \textbf{if} $ T\geq a_i $ \textbf{then}\\
\>\> \> $ T:=T-s_i $\\
\>\>\> $ x_i:=1 $\\
\>\> \textbf{else}\\
\>\>\> $ x_i:=0 $\\
\>\textbf{if} $ T=0 $ \textbf{then}\\
\>\> $ X:=(x_1, \dots, x_n) $ ist die Lösung.\\
\>\textbf{else}\\
\>\> Es gibt keine Lösung.
\end{tabbing}
\caption{Lösen von Knapsackproblemen mit superwachsenden Gewichten}
\label{knapsackalgo}
\end{cryptoprocedure}


%--------------------------------------------------------------------
\subsection{Merkle-Hellman Knapsack-Verschlüsselung}
\index{Hellman, Martin} \index{Merkle, Ralph}

1978 gaben Merkle und Hellman \cite{Merkle1978} \index{Verschlüsselung!Merkle-Hellman} ein Public-Key-Verschlüsselungs-Verfahren an, das darauf beruht, das leichte 0-1-Knapsackproblem mit einer superwachsenden Folge in ein kongruentes mit einer nicht superwachsenden Folge zu \glqq verfremden\grqq. Es ist eine Blockchiffrierung, die bei jedem Durchgang einen $n$ Bit langen Klartext chiffriert, siehe Krypto-Verfahren \ref{merklehellmanproc}.
\index{Knapsack!Merkle-Hellman}

% \begin{cryptoprocedure}[ht]
\begin{cryptoprocedure}
Es sei $ (a_1, \dots, a_n) $ superwachsend. Seien $ m $ und $ w $ zwei
teilerfremde\index{Zahlen!teilerfremd (co-prime)} Zahlen mit $ m >
\sum_{i=1}^{n} a_i $ und $ 1\leq w \leq m-1. $
Wähle $\bar{w} $ mit $ w \bar{w} \equiv 1 \mod m $ die modulare Inverse
von $ w $ und setze $ b_i:= wa_i \mod m, $ $ 0\leq b_i < m $ für $ i=1,
\dots ,n, $ und prüfe, ob die Folge $ b_1, \dots b_n $ nicht superwachsend
ist. Danach wird eine Permutation $ b_{\pi (1)}, \dots , b_{\pi(n)} $
von $ b_1, \dots , b_n $ publiziert und insgeheim die zu $ \pi $ inverse
Permutation $ \mu $ festgehalten. Ein Sender schreibt seine Nachricht
in Blöcke $ (x_1^{(j)}, \dots, x_n^{(j)}) $ von Binärzahlen der Länge
$ n $ und bildet \[ g^{(j)}:= \sum_{i=1}^n x_{i}^{(j)} b_{\pi(i)} \]
und sendet $ g^{(j)}, (j=1,2, \dots). $\par
Der Schlüsselinhaber bildet
\[ G^{(j)}:=\bar{w} g^{(j)} \mod m ,\quad 0 \leq G^{(j)} < m \]
und verschafft sich die $ x_{\mu(i)}^{(j)} \in \{ 0,1\} $ (und somit auch die $ x_i^{(j)} $) aus
\begin{eqnarray*}
G^{(j)} & \equiv & \bar{w} g^{(j)} = \sum_{i=1}^n x_i^{(j)} b_{\pi (i)} \bar{w} \equiv \sum_{i=1}^n x_i^{(j)} a_{\pi (i)} \mod m\\
& = & \sum_{i=1}^n x_{\mu (i)}^{(j)} a_{\pi (\mu (i))} = \sum _{i=1}^n x_{\mu (i)}^{(j)} a_i \mod m,
\end{eqnarray*}
indem er die leichten 0-1-Knapsackprobleme $ K(a_1,\dots,a_n;G^{(j)}) $ mit superwachsender Folge $ a_1, \dots,a_n $ löst.
\caption{Merkle-Hellman (auf Knapsackproblemen basierend)}
\label{merklehellmanproc}
\end{cryptoprocedure}



1982 gab \index{Shamir, Adi} Shamir \cite{Shamir1982} einen Algorithmus zum
Brechen des Systems in polynomialer \index{Polynom} Zeit an, ohne das allgemeine
Knapsackproblem zu lösen. Len \index{Adleman, Leonard} Adleman
\cite{Adleman1982} und Jeff Lagarias \index{Lagarias, Jeff}
\cite{Lagarias1983} gaben einen Algorithmus zum Brechen des 2-fachen
iterierten Merkle-Hellman Knapsack-Verschlüsselungsver"-fah"-rens in
polynomialer Zeit an. Ernst Brickell \index{Brickell, Ernst}
\cite{Brickell1985} gab schließlich einen Algorithmus zum Brechen des
%mehrfachen iterierten Merkle-Hellman Knapsack-Verschlüsselungs"-ver"-fah"-ren in
mehrfachen iterierten Merkle-Hellman Knapsack-Ver\-schlüsse\-lungs\-ver\-fah\-ren in
polynomialer Zeit an. Damit war dieses Verfahren als
Verschlüsse"-lungs"-ver"-fah"-ren ungeeignet. Dieses Verfahren liefert also eine
Einwegfunktion, deren Falltür-In"-for"-ma"-tion (Verfremden des
0-1-Knapsackproblems) durch einen Gegner entdeckt werden könnte.



%---------------------------------------------------------------------
\clearpage
\section{Primfaktorzerlegung als Basis für Public-Key-Verfahren}
\index{Primfaktor!Zerlegung}

Primzahlen sind Grundlage für eine große Anzahl von Algorithmen für Public-Key-Verfahren.


%--------------------------------------------------------------------
\hypertarget{RSAVerfahren}{}
\subsection[Das RSA-Verfahren]{Das RSA-Verfahren\footnote{%
  Vergleiche auch die Kapitel \ref{rsabeweis}, ff.
}$^,$\footnote{%
Mit CT1\index{CT1} können Sie praktische Erfahrungen
mit dem RSA-Verfahren sammeln: per Menü \textbf{Einzelverfahren
\textbackslash{} RSA-Kryptosystem \textbackslash{} RSA-Demo}.\\
RSA finden Sie ebenfalls in CT2\index{CT2} und JCT\index{JCT}.
}
}
\index{RSA} \label{rsaverfahren}

Bereits 1978 stellten R. \index{Rivest, Ronald} Rivest,
\index{Shamir, Adi} A. Shamir,  \index{Adleman, Leonard} L. Adleman
\cite{rivest/shamir/adleman:1978} das bis heute wichtigste
asymmetrische Kryptographie-Verfahren vor (Krypto-Verfahren~\ref{rsaproc}).


\index{Faktorisierung!Faktorisierungsproblem}
\index{Eulersche Phi-Funktion}
\begin{cryptoprocedure}
\textbf{Schlüsselgenerierung:}

Seien $p$ und $q$ zwei verschiedene Primzahlen und $N=pq.$
Sei $e$ eine frei wählbare, zu $ \phi (N) $ relativ prime Zahl
\index{Primzahl!relativ}\index{Zahlen!relativ prim},
d.h. $ \ggt (e,\phi (N))=1. $ Mit dem Euklidschen Algorithmus berechnet
man die natürliche Zahl  $ d < \phi (N), $ so dass gilt

\[ ed \equiv 1 \mod \phi (N). \]
Dabei ist $ \phi $ die \textbf{Eulersche Phi-Funktion}.

Der Ausgangstext wird in Blöcke zerlegt und verschlüsselt, wobei jeder Block einen binären Wert $ x^{(j)} \leq N $ hat. \vskip + 5 pt

\textbf{Öffentlicher Schlüssel:}
\[ N,e. \]
\textbf{Privater Schlüssel:}
\[ d. \]
\textbf{Verschlüsselung:}
\[ y= e_{T} (x) = x^{e} \mod N.\]
\textbf{Entschlüsselung:}
\[ d_{T} (y) = y^d \mod N \]
\caption{RSA (auf dem Faktorisierungsproblem basierend)}
\label{rsaproc}
\end{cryptoprocedure}



\newpage
\begin{remark}{: Eulersche Phi-Funktion}\\
\label{mc:Euler-phi} \hypertarget{mc:Euler-phi}{}
\index{Eulersche Phi-Funktion}

\vskip +10 pt
Die Eulersche Phi-Funktion ist definiert durch:

\fbox{\parbox{0.8\linewidth}{
\centering
  $ \phi (n)$ ist die Anzahl der natürlichen Zahlen $ x < n$,\\
  die mit $ n $ keinen gemeinsamen Faktor haben.
}}

\vskip +10 pt
Kein gemeinsamer Faktor bedeutet: Zwei natürliche Zahlen $ a $ und $ b $
sind teilerfremd\index{Zahlen!teilerfremd (co-prime)}, falls $ \ggt (a,b)=1. $

\vskip +10 pt
Für die Eulersche Phi-Funktion gilt:
\[
\phi(1)=1,~~ \phi(2)=1,~~
\phi(3)=2,~~ \phi(4)=2,~~ \phi(6)=2,~~ \phi(10)= 4,~~ \phi(15)=8.
\]

Zum Beispiel ist $ \phi (24)=8, $ weil
\[
|\{ x <24 : \ggt (x,24) =1 \}| =|\{1,5,7,11,13,17,19,23\}|.
\]


Tabelle~\ref{phi15} zeigt Werte von $ \phi(n)$ bis $25$.

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|l|}\hline
$n$  &  $\phi(n) $  &  Die zu $ n $ teilerfremden\index{Zahlen!teilerfremd
(co-prime)} natürlichen Zahlen kleiner $n$.\\ \hline
1 & 1 & 1\\
2 & 1 & 1\\
3 &  2 & 1, 2\\
4 &  2 & 1, 3\\
5 &  4 & 1, 2, 3, 4\\
6 &  2 & 1, 5\\
7 &  6 & 1, 2, 3, 4, 5, 6\\
8 &  4 & 1, 3, 5, 7\\
9 &  6 & 1, 2, 4, 5, 7, 8\\
10 &  4 & 1, 3, 7, 9\\
15 &  8 & 1, 2, 4, 7, 8, 11, 13, 14\\
20 &  8 & 1, 3, 7, 9, 11, 13, 17, 19\\
25 &  20 & 1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24\\ \hline
\end{tabular}
\end{center}
\caption{Eulersche Phi-Funktion}
\label{phi15}
\end{table}


Ist $ p $ eine Primzahl, so gilt $ \phi (p)= p-1$.\\

Im Spezialfall $ N=pq $ gilt:
\[
\phi (N)= pq(1-1/p)(1-1/q) = p(1-1/p)q(1-1/q)=(p-1)(q-1).
\]


Kennt man die verschiedenen Primfaktoren $ p_1, \dots , p_k $ von $ n $, so ist
\[
\phi (n) = n \cdot (1-\frac{1}{p_1}) \,
\cdots \, (1-\frac{1}{p_k}).\footnote{%
  Weitere Formeln zur Eulerschen Phi-Funktion finden sich in Kapitel~\ref{L-Euler-Function}
  \glqq \nameref{L-Euler-Function}\grqq.
}
\]

\end{remark}
\newpage



Die Funktion $ e_T $  ist eine Einwegfunktion, deren Falltür-Information die
Primfaktorzerlegung von $ N $ ist.

Zur Zeit ist kein Algorithmus bekannt, der das Produkt zweier Primzahlen bei sehr großen
Werten geeignet schnell zerlegen kann (z.B. bei mehreren hundert Dezimalstellen). Die
heute schnellsten bekannten Algorithmen \cite{Stin2006} zerlegen eine zusammengesetzte
ganze Zahl $ N $ in einem Zeitraum proportional zu $ L(N)= e^{\sqrt{\ln (N) \ln (\ln (N))}}.$
Einige Beispielwerte finden sich in Tabelle~\ref{lnvalues}.
\begin{table}[ht]
\begin{center}
\begin{tabular}{|l||l|l|l|l|l|l|}\hline
$N$ & $ 10^{50} $ & $ 10^{100} $ & $ 10^{150} $ & $ 10^{200} $ & $ 10^{250} $ & $ 10^{300} $\\ \hline
$L(N)$ & $ 1,42 \cdot 10^{10} $ &  $ 2,34  \cdot 10^{15} $ &  $ 3,26 \cdot 10^{19} $ &  $ 1,20 \cdot 10^{23} $ &  $ 1,86 \cdot 10^{26} $ &  $ 1,53 \cdot 10^{29} $\\ \hline
\end{tabular}
\end{center}
\caption{Wertetabelle für $L(N)$ [Faktorisierungsaufwand bezogen auf die Modullänge]}
\label{lnvalues}
\end{table}

Bewiesen ist bis heute nicht, dass das Problem, RSA zu brechen, äquivalent zum
Faktorisierungsproblem \index{Faktorisierung!Faktorisierungsproblem} ist. Es ist
aber klar, dass wenn das Faktorisierungsproblem \glqq gelöst\grqq {} ist, dass
dann das RSA-Verfahren nicht mehr sicher ist.\footnote{%
Im Jahre 2000 waren die Autoren der Ansicht, dass Werte der
Größenordnung $ 100 $ bis $ 200 $ Dezimalstellen sicher sind. Sie schätzten,
dass mit der aktuellen Computertechnik eine Zahl mit $100$
Dezimalstellen bei vertretbaren Kosten in etwa zwei Wochen zerlegt werden
könnte, dass mit einer teuren Konfiguration (z.B. im Bereich von 10 Millionen
US-Dollar) eine Zahl mit $150$ Dezimalstellen in etwa einem Jahr zerlegt
werden könnte und dass eine $200$-stellige Zahl noch für eine sehr lange Zeit
unzerlegbar bleiben dürfte, falls es zu keinem mathematischen Durchbruch kommt.
Dass es aber nicht doch schon morgen zu einem mathematischen Durchbruch kommt,
kann man nie ausschließen.\\
Wie leicht man sich verschätzen kann, zeigt die
\hyperlink{RSA-200-chap3}{Faktorisierung von RSA-200}
(siehe Kapitel \ref{nt:NoteFactorization}) -- ganz ohne \glqq mathematische
Durchbrüche\grqq.}



%--------------------------------------------------------------------
\subsection{Rabin-Public-Key-Verfahren (1979)}

Für \index{Rabin, Michael O.} \index{Rabin!Public-Key-Verfahren}
dieses Verfahren (\ref{rabinproc}) konnte gezeigt werden, dass es äquivalent zum
Brechen des Faktorisierungsproblems ist. Leider ist dieses Verfahren anfällig
gegen Chosen-Ciphertext-Angriffe.
\index{Angriff!Chosen-Ciphertext}
\begin{cryptoprocedure}
Seien $ p $ und $ q $ zwei verschiedene Primzahlen mit $ p,q\equiv 3 \mod 4 $ und $ n = pq.$ Sei $ 0\leq B \leq n-1.$\\
\textbf{Öffentlicher Schlüssel:}
\[ e=(n,B). \]
\textbf{Privater Schlüssel:}
\[ d=(p,q). \]
\textbf{Verschlüsselung:}
\[ y= e_{T} (x) = x(x+B) \mod n.\]
\textbf{Entschlüsselung:}
\[ d_{T} (y) = \sqrt{y + B^2/4} -B/2 \mod n. \]
\caption{Rabin (auf dem Faktorisierungsproblem basierend)}
\label{rabinproc}
\end{cryptoprocedure}

Vorsicht:
Wegen $ p,q \equiv 3 \mod 4 $  ist die Verschlüsselung (mit Kenntnis des Schlüssels) leicht  zu berechnen. Dies ist nicht der Fall für $ p \equiv 1 \mod 4. $ Außerdem ist die Verschlüsselungsfunkti"-on nicht injektiv: Es gibt genau vier verschiedene Quellcodes, die $ e_T(x) $  als Urbild besitzen $ x,-x-B,\omega (x+B/2)-B/2, -\omega(x+B/2)-B/2, $ dabei ist  $ \omega $  eine der vier Einheitswurzeln. Es muss also eine  Redundanz der Quellcodes geben, damit die Entschlüsselung trotzdem eindeutig bleibt!

Hintertür-Information ist die Primfaktorzerlegung von $ n = pq. $



\vskip +20 pt
%--------------------------------------------------------------------
\hypertarget{HT-Discrete-Logarithm-as-Basis}{}
\section[Der diskrete Logarithmus als Basis für Public-Key-Verfahren]
           {Der diskrete Logarithmus als Basis für Public-Key-Verfah"-ren\footnotemark}
\footnotetext{%
    \index{ZT, Lernprogramm Zahlentheorie}%
    \index{Lernprogramm ZT}%
    In dem Lernprogramm \textbf{ZT} können Sie mit der Verteilung des diskreten
    Logarithmus experimentieren und Shanks Babystep-Giantstep-Methode
    anwenden:
    Siehe Lern-Kapitel 6.1-6.3, Seiten 1-6/6.\\
    ZT können Sie in CT1\index{CT1} über das Menü
    \textbf{Einzelverfahren \textbackslash{} Zahlentheorie
    interaktiv \textbackslash{} Lernprogramm für Zahlentheorie} aufrufen.
    Siehe Anhang \ref{s:appendix-Learn-NT}.
}
\label{L-Discrete-Logarithm-as-Basis}
\index{DL-Problem}\index{Logarithmusproblem!diskret}
\index{diskreter Logarithmus}
Diskrete Logarithmen sind die Grundlage für eine große Anzahl von
Algorithmen für Public-Key-Verfahren.


%--------------------------------------------------------------------
\subsection{Der diskrete Logarithmus in \texorpdfstring{$ \Z_p^* $}{Zp*}}
\label{L_Discrete_Logarithm}  %Die Kapitelnr von \label wird per \ref geholt.

Sei $ p $ eine Primzahl, und sei $g$ ein Erzeuger der zyklischen multiplikativen Gruppe $ \Z_p^\ast=\{1,\ldots,p-1\} $. Dann ist die diskrete Exponentialfunktion zur Basis $ g $  definiert durch
\[ e_g : k \longrightarrow y:=g^k \mod p, \quad 1\leq k \leq p-1. \]
Die Umkehrfunktion wird diskrete Logarithmusfunktion $ \log_g $ genannt; es gilt
\[ \log_g (g^k) =k. \]
\index{Exponentialfunktion!diskret} Unter dem Problem des diskreten Logarithmus (in $ \Z_p^\ast$) versteht man das folgende:
\[ \text{Gegeben } p,g \text{~(ein Erzeuger der Gruppe } \Z_p^* \text{) und } y, \text{ bestimme } k \text{ so, dass } y=g^k \mod p \text{ gilt.}\]
Die Berechnung des diskreten Logarithmus ist viel schwieriger als die Auswertung der diskreten Exponentialfunktion (siehe Kapitel \ref{MultOrdPrimitveRoot}).
Tabelle~\ref{dlogprocs} listet verschiedene Verfahren zur Berechnung des diskreten
Logarithmus \cite{Stin2006} und ihre Komplexität.
\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|}\hline
Name                 &        Komplexität\\ \hline \hline
Babystep-Giantstep   &         $ O(\sqrt{p}) $\\ \hline
Silver-Pohlig-Hellman &    polynomial in $ q, $ dem größten\\
&  Primteiler von $ p-1. $\\ \hline
Index-Calculus &             $ O(e^{(1+o(1)) \sqrt{\ln (p) \ln (\ln (p))}}) $\\ \hline
\end{tabular}
\end{center}
\index{Silver} \index{Pohlig, S. C.} \index{Hellman, Martin}
\index{Babystep-Giantstep}
\caption{Verfahren zur Berechnung des diskreten Logarithmus in $ \Z_p^\ast$}
\label{dlogprocs}
\end{table}


% BE_2018: TODOTODO: Aktualisieren !
% Der aktuelle Rekord\index{Logarithmusproblem!Rekord} (Stand April 2007) für die Berechnung
% des diskreten Logarithmus wurde im Februar 2007 von der 
%% BE_8.8.18: Link tot: \footnote{%
%%   \url{http://www.nabble.com/Discrete-logarithms-in-GF(p)-----160-digits-t3175622.html}}
Im Februar 2007 stellte die Gruppe Kleinjung, Franke und Bahr an der Universität Bonn
den damaligen Rekord\index{Logarithmusproblem!Rekord} für die Berechnung
des diskreten Logarithmus auf.
Sie berechneten den diskreten Logarithmus modulo einer
160-stelligen Prim"-zahl $p$ und Erzeuger $g$:
$$
\begin{array}{r@{\:}c@{\:}l}
p & = & \lfloor 10^{159}\pi\rfloor + 119849\\
  & = & 314159265358979323846264338327950288419716939937510582097494\\
  &   & 459230781640628620899862803482534211706798214808651328230664\\
  &   & 7093844609550582231725359408128481237299\\
g & = & 2
\end{array}
$$
Konkret wurde der diskrete Logarithmus $k$ von folgender Zahl $y$
berechnet:\footnote{Die Zahl $y$ ergab sich aus den ersten 159 Stellen der
Eulerschen Zahl $e$.}
$$
\begin{array}{r@{\:}c@{\:}l}
y & = & \lfloor 10^{159}e\rfloor\\
  & = & 271828182845904523536028747135266249775724709369995957496696\\
  &   & 762772407663035354759457138217852516642742746639193200305992\\
  &   & 1817413596629043572900334295260595630738\\
k & = & \log_g(y)\mod p\\
  & = & 829897164650348970518646802640757844024961469323126472198531\\
&   & 845186895984026448342666252850466126881437617381653942624307\\
&   & 537679319636711561053526082423513665596
\end{array}
$$
Die Suche wurde mit der GNFS-Methode (General Number Field Sieve,
Index-Calculus) \index{General Number Field Sieve (GNFS)} durch"-geführt und
benötigte ca.~17 CPU-Jahre auf 3.2 GHz Xeon Maschinen.

%--------------------------------------------------------------------
\subsection[Diffie-Hellman-Schlüsselvereinbarung]
{Diffie-Hellman-Schlüsselvereinbarung\footnotemark}
\footnotetext{%
  In CT1\index{CT1} ist dieses Austauschprotokoll visualisiert:
  Sie können die einzelnen Schritte mit konkreten Zahlen nachvollziehen
  per Menü \textbf{Einzelverfahren \textbackslash{} Protokolle \textbackslash{}
  Diffie-Hellman-Demo}.\\
  In JCT\index{JCT} findet man es in der Standard-Perspektive
  über den Menüeintrag \textbf{Visualisierungen \textbackslash{}
  Diffie-Hellman-Schlüsselaustausch (EC)}.
}
\index{Diffie, Whitfield}
\index{Hellman, Martin}
\index{Diffie-Hellman}
\hypertarget{DH-KeyExch}{} \label{DH-KeyExch}

Die Mechanismen und Algorithmen der klassischen Kryptographie greifen erst dann, wenn die Teilnehmer bereits den geheimen Schlüssel ausgetauscht haben. Im Rahmen der klassischen Kryptographie  führt kein Weg daran vorbei, dass Geheimnisse kryptographisch ungesichert ausgetauscht werden müssen. Die Sicherheit der Übertragung muss hier durch nicht-kryptogra"-phische Methoden erreicht werden. Man sagt dazu, dass man zum Austausch der Geheimnisse einen geheimen Kanal braucht; dieser kann physikalisch oder organisatorisch realisiert sein.\\
Das Revolutionäre der modernen Kryptographie ist unter anderem, dass man keine geheimen Kanäle mehr braucht: Man kann geheime Schlüssel über nicht-geheime, also öffentliche Kanäle vereinbaren.\\
Ein Protokoll, das dieses Problem löst, ist das von Diffie und Hellman (Krypto-Verfahren~\ref{diffiehellmanproc}).

\begin{cryptoprocedure}
Zwei Teilnehmer $ A $ und $ B $ wollen einen gemeinsamen geheimen Schlüssel vereinbaren. \par
Sei $ p $ eine Primzahl und $ g $ eine natürliche Zahl. Diese beide Zahlen müssen nicht geheim sein.\\
Zunächst wählen sich die beiden Teilnehmer je eine geheime Zahl $ a $ bzw. $ b. $ Daraus bilden sie die Werte $ \alpha = g^{a}\mod p $ und $ \beta = g^b \mod p. $ Dann werden die Zahlen $ \alpha $ und $ \beta $ ausgetauscht. Schließlich potenziert jeder den erhaltenen Wert mit seiner geheimen Zahl und erhält $ \beta^{a} \mod p $ bzw. $ \alpha^b \mod p. $\\
Damit gilt
\[ \beta^{a} \equiv (g^b)^{a} \equiv g^{ba} \equiv g^{ab} \equiv (g^{a})^b \equiv \alpha^b \mod p \]
\caption{Diffie-Hellman-Schlüsselvereinbarung}
\label{diffiehellmanproc}
\end{cryptoprocedure}

Die Sicherheit des \textbf{Diffie-Hellman-Protokolls} hängt eng mit der Berechnung des diskreten Logarithmus modulo $p$ zusammen. Es wird sogar vermutet, dass diese Probleme äquivalent sind.


%--------------------------------------------------------------------
\subsection{ElGamal-Public-Key-Verschlüsselungsverfahren in \texorpdfstring{$ \Z_p^\ast$}{Zp*}}
\index{ElGamal!Public-Key}
\index{Verschlüsselung!ElGamal-Public-Key}

Indem man das Diffie-Hellman Schlüsselvereinbarungsprotokoll\index{Diffie-Hellman}
leicht variiert, kann man einen asymmetrischen Verschlüsselungsalgorithmus
erhalten (Krypto-Verfahren~\ref{elgamalproc}). Diese Beobachtung geht auf Taher ElGamal zurück.
\begin{cryptoprocedure}
Sei $p$ eine Primzahl, so dass der diskrete Logarithmus in $\Z_p$ schwierig zu berechnen ist.
Sei $ \alpha \in \Z_p^\ast $ ein primitives Element. Sei $a \in \mathbb{N}$ eine natürliche Zahl und $ \beta = \alpha^{a}  \mod p. $\\
\textbf{Öffentlicher Schlüssel:}
\[ p,\alpha,\beta. \]
\textbf{Privater Schlüssel:}
\[a. \]
Sei $ k \in \Z_{p-1} $ eine zufällige Zahl und $ x \in \Z_p^{\ast} $ der Klartext.\\
\textbf{Verschlüsselung:}
\[ e_T(x,k)=(y_1,y_2), \]
wobei
\[ y_1=\alpha^k \mod p,\]
und
\[ y_2 = x\beta^k \mod p.\]
\textbf{Entschlüsselung:}
\[ d_T(y_1,y_2)= y_2 (y_1^{a})^{-1} \mod p. \]
\caption{ElGamal (auf dem diskreten Logarithmusproblem basierend)}
\label{elgamalproc}
\end{cryptoprocedure}


%--------------------------------------------------------------------
\subsection{Verallgemeinertes ElGamal-Public-Key-Verschlüsselungs\-ver\-fahren }

Den diskreten Logarithmus kann man in beliebigen endlichen \index{Gruppe} Gruppen $ (G, \circ) $ verallgemeinern. Im Folgenden geben wir einige Eigenschaften über die Gruppe $G$ an, die das diskrete Logarithmusproblem schwierig machen.
Dabei schreiben wir statt $g\circ h$ oft nur $g h$.\\

\index{Exponentialfunktion!Berechnung}
\paragraph*{Berechnung der diskreten Exponentialfunktion}
Sei $ G $ eine Gruppe mit der Operation $ \circ $ und $ g \in G. $ Die (diskrete) Exponentialfunktion  zur Basis $ g $ ist definiert durch
\[e_g: k \longmapsto g^k, \quad \text{ für alle } k \in \mathbb{N}. \]
Dabei definiert man
 \[ \ g^{k}:=\underbrace{g \circ \ldots \circ g}_{k \text{ mal}}.\]
Die Exponentialfunktion ist leicht zu berechnen:

\vskip +10 pt 
\textbf{Lemma}\par
\nopagebreak[4]
{\em
Die Potenz $ g^k $ kann in höchstens $ 2 \log_2 k $ Gruppenoperationen
berechnet werden.
}

\vskip +10 pt
\begin{Beweis}{}
Sei $ k=2^n + k_{n-1} 2^{n-1} + \cdots + k_1 2 + k_0 $ die Binärdarstellung von $k. $ Dann ist $ n \leq \log_2 (k), $  denn $ 2^n \leq k < 2^{n+1}. $ $ k $ kann in der Form $ k=2k' + k_0 $ mit $ k'= 2^{n-1} + k_{n-1} 2^{n-2} + \cdots + k_1 $ geschrieben werden. Es folgt
\[ g^k = g^{2k'+k_0}= (g^{k'})^2 g^{k_0} .\]
Man erhält also $ g^k $ aus $ g^{k'} $ indem man einmal quadriert und eventuell mit $ g $ multipliziert. Damit folgt die Behauptung durch Induktion nach $ n. $
\end{Beweis}

\vskip +10 pt
\textbf{Problem \index{Logarithmusproblem!diskret} des diskreten Logarithmus}
\begin{center}
\fbox{\parbox{.75\textwidth}{
Sei $ G $ eine endliche Gruppe mit der Operation $ \circ. $ Sei $ \alpha \in G $ und \mbox{$ \beta \in H=\{ \alpha^{i}: i\geq 0\}. $}\\
Gesucht ist das eindeutige $ a \in \mathbb{N} $ mit $ 0 \leq a \leq |H| -1 $ und $ \beta = \alpha^{a}. $\\
Wir bezeichnen $ a $ mit $ \log_\alpha (\beta). $
}}
\end{center}

\paragraph*{Berechung des diskreten Logarithmus}
Ein einfaches Verfahren zur Berechnung des dis"-kreten Logarithmus eines Gruppenelements, das wesentlich effizienter ist als das bloße Durchprobieren aller möglichen Werte für $ k, $ ist der \index{Babystep-Giantstep} Babystep-Giantstep-Algorithmus.

\begin{satz}[Babystep-Giantstep-Algorithmus]\label{thm-cry-bsgs}
Sei $ G $ eine Gruppe  und $ g \in G. $ Sei $ n $ die kleinste natürliche Zahl mit
$ |G|\leq n^2. $ Dann kann der diskrete Logarithmus eines Elements $ h \in G $ zur
Basis $ g $ berechnet werden, indem man die folgenden zwei Listen mit jeweils $ n $
Elementen erzeugt und diese Listen vergleicht:\\
\centerline{Giantstep-Liste: $ \{1,g^n,g^{2n}, \ldots, g^{n \cdot n}\}, $}\\
\centerline{Babystep-Liste: $ \{ hg^{-1} , hg^{-2} , \ldots , hg^{-n} \}.$}\\
Dabei kann man nach Feststellen eines gemeinsamen Elements die Berechnung abbrechen.
Zur Berechnung dieser Listen braucht man $ 2n $ Gruppenoperationen.
\end{satz}

\begin{Beweis}{}
Falls $ g^{jn} = hg^{-i}, $ also $ h = g^{i+jn}, $ so ist das Problem gelöst. Falls
die Listen disjunkt sind, so ist $ h $ nicht als $ g^{i + jn}, i, j\leq n,$ darstellbar.
Da dadurch alle Potenzen von $ g $ erfasst werden, hat das Logarithmusproblem keine Lösung.
\end{Beweis}

Man kann sich mit Hilfe des Babystep-Giantstep-Algorithmus klar machen, dass die Berechnung des diskreten Logarithmus sehr viel schwieriger ist als die Berechnung der diskreten Exponentialfunktion. Wenn die auftretenden Zahlen etwa 1000 Bit Länge haben, so benötigt man zur Berechnung aller $ g^k $ nur etwa 2000 Multiplikationen (siehe Satz \ref{thm-cry-bsgs}), zur Berechnung des diskreten Logarithmus mit dem Babystep-Giantstep-Algorithmus aber etwa $ 2^{500} \approx 10^{150} $ Operationen.\\
Neben dem Babystep-Giantstep-Algorithmus gibt es noch zahlreiche andere Verfahren zur Be"-rechnung des diskreten Logarithmus \cite{Stin2006}.

\paragraph*{Der Satz von Silver-Pohlig-Hellman}
In endlichen abelschen Gruppen lässt sich das  dis"-krete Logarithmusproblem in Gruppen kleinerer Ordnung reduzieren.

\begin{satz}[Silver-Pohlig-Hellman]\label{thm-cry-pohe}
Sei $ G $ eine endliche abelsche Gruppe mit $ |G|= p_1^{a_1} p_2^{a_2} \cdot \ldots \cdot p_s^{a_s}. $ Dann lässt sich das diskrete Logarithmusproblem in $ G $ auf das Lösen von Logarithmenproblemen in Gruppen der Ordnung $ p_1, \ldots , p_s $ zurückführen.
\end{satz}

Enthält $ |G| $ einen \glqq dominanten\grqq {} Primteiler $ p ,$ so ist die Komplexität \index{Komplexität} des Logarithmusproblems ungefähr
\[ O(\sqrt{p}). \]

Wenn also das Logarithmusproblem schwer sein soll, so muss die Ordnung der verwendeten Gruppe $ G $ einen großen Primteiler haben. Insbesondere gilt, wenn die diskrete Exponentialfunktion in der Gruppe $ \Z_p^{\ast} $ eine Einwegfunktion sein soll, so muss $ p -1 $ einen großen Primteiler haben. In diesem Fall kann man ein verallgemeinertes ElGamal-Verfahren definieren (Krypto-Verfahren~\ref{genelgamalproc}).

\begin{cryptoprocedure}
\vskip +6pt
Sei $ G $ eine endliche Gruppe  mit Operation $ \circ $, und sei $ \alpha \in G $,
so dass der diskrete Logarithmus in $ H =\{ \alpha^{i}: i \geq 0 \} $ schwer zu
berechnen ist. Sei $ a $ mit $ 0 \leq a \leq |H| -1 $ und sei $ \beta = \alpha^{a} $.\\

\textbf{Öffentlicher Schlüssel:}
\[ \alpha,\beta \]
\textbf{Privater Schlüssel:}
\[a \]
Sei $ k \in \Z_{|H|} $ eine zufällige Zahl, $ k\neq 0$, und $ x \in G $ ein Klartext.\\

\textbf{Verschlüsselung:}
\[ e_T(x,k)=(y_1,y_2), \]
wobei
\[ y_1=\alpha^k \]
und
\[ y_2 = x\circ \beta^k .\]\\

\textbf{Entschlüsselung:}
\[ d_T(y_1,y_2)= y_2\circ (y_1^{a})^{-1}.  \]
\caption{Verallgemeinertes ElGamal (auf dem diskreten Logarithmusproblem basierend)}
\label{genelgamalproc}
\end{cryptoprocedure}

\vskip +25pt
\hyperlink{Chapter_EllipticCurves}{Elliptische Kurven}{} (siehe Kapitel \ref{Chapter_EllipticCurves})
liefern nützliche Gruppen für Public-Key-Verschlüsselungs\-ver\-fahren.



%------------------------------------------------------------------------------
\printbibliography[%
	heading=subbibintoc,
	title={Literatur zu Kapitel \thechapter},
	segment=\therefsegment,
]


Alle Links wurden am 13.07.2016 überprüft.



\end{refsegment}

