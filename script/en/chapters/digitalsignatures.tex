% $Id$
% ...........................................................................
%                  D I G I T A L E  S I G N A T U R E N
% ...........................................................................

\newpage
% --------------------------------------------------------------------------
\section{Hash Functions and Digital Signatures}
\index{Signature!digital}
(Schneider J. / Esslinger B. / Filipovics B. / Koy H., June 2002,
Update: Feb. 2003)

\vspace{12pt}
The aim of digital signatures is to guarantee the following two points:
\begin{itemize}
 \item User authenticity: \index{Authenticity!user} \\
      It can be checked whether a message really does
come from a particular person.
 \item Message integrity:  \index{Message integrity} \\
      It can be checked whether the message has been
changed (on route).
\end{itemize}


An asymmetric technique is used again (see encryption procedures). Participants
who wish to generate a digital signature for a document must possess a pair of
keys. They use their secret key to generate signatures and the recipient uses
the sender's public key to verify whether the signature is correct. As before,
it must be impossible to use the public key to derive the secret key\footnote{%
With CrypTool\index{CrypTool} v1.3 you can also generate and check 
digital signatures: \\
using the submenus of the main menu {\bf Digital Signatures} or \\
using menu {\bf Indiv. Procedures \textbackslash{} RSA Demonstration 
\textbackslash{} Signature Demonstration}.
}.


In detail, a \index{Signature procedure} {\em Signature procedure} looks like
this: \\ Senders use their message and secret key to calculate the digital
signature for the message. Compared to hand-written signatures, digital
signatures therefore have the advantage that they also depend on the document to
be signed. Signatures from one and the same participant are different unless the
signed documents are completely identical. Even inserting a blank in the text
would lead to a different signature. The recipient of the message would
therefore detect any injury to the message integrity as this would mean that the
signature no longer matches the document and is shown to be incorrect when
verified.

The document is sent to the recipient together with the signature. The recipient
can then use the sender's public key, the document and the signature to
establish whether or not the signature is correct. In practice, however, the
procedure we have just described has a decisive disadvantage. The signature is
approximately as long as the document itself. To prevent an unnecessary increase
in data traffic, and also for reasons of performance\index{Performance}, we use 
a cryptographic hash function\footnote{%
Hash functions\index{Hash function} are implemented within 
CrypTool\index{CrypTool} v1.3.04 at several places.\\
Using menus {\bf Individual Procedures \textbackslash{} Hash} and
            {\bf Individual Procedures \textbackslash{} Attack on the Hash
	         Value of the Digital Signature}
you have the possibilities
% hier die items nicht einrücken!
\begin{list}{\textbullet}{\leftmargin10pt\addtolength{\itemsep}{-1.0\baselineskip}}
%\begin{itemize}\addtolength{\itemsep}{-1.0\baselineskip} % um den Abstand zu verringern bebe
\item to apply one of 6 hash functions to the content of the current window, \\
\item to calculate the hash value of a file, \\
\item to test, how changes to a text change the according hash value and \\
\item to perform a simulation, how digital signatures could be attacked 
      by a targeted search for hash value collisions\index{Collision}.
\end{list}
}.


% --------------------------------------------------------------------------
\subsection{Hash functions}
\index{Hash function}
A cryptographic \index{Hash function} {\em hash function}\footnote{%
Secure hash algorithms compute a condensed representation of 
electronic data (message).
When a message is input to a hash algorithm, the result is an output called
a message digest. The message digests typically range in length 
from 128 to 512 bits, depending on the algorithm. 
Secure hash algorithms are typically used with
other cryptographic algorithms, such as digital signature algorithms and
keyed-hash message authentication codes, or in the generation of random
numbers (bits).
}
maps a message of any
length to a string of characters with a constant size,
the \index{Hash value} hash value. It should be practically impossible, for a
given number, to find a message that has precisely this number as hash value.
Furthermore, it should be practically impossible to find two messages with the
same hash value\index{collisions}. 
In both cases the final signature procedure would have weaknesses.

So far, no formal proof has been found that perfectly secure cryptographic
hash functions exist. However, there are several good candidates that have
not yet shown any weak points in their structure in practice 
(e.g. \index{SHA-1} SHA--1\footnote{%
SHA-1 \index{SHA-1} is a 160 bit hash function specified in FIPS 180-1, 
ANSI X9.30 Part 2 and \cite{FIPS186}.\\
SHA means Secure Hash Algorithm, and is widely used, 
e.g. with DSA, RSA or ECDSA.\\
The current standard \cite{FIPS180-2} defines four secure hash algorithms
-- SHA-1, SHA-256, SHA-384, and SHA-512.
For these hash algorithms there are also validation tests defined in the
test suite FIPS 140-2.

The output length of the SHA algorithms was enhanced because of the
possibility of birthday attacks\index{Birthday attack}\index{collisions}:
these make n-bit AES and a 2n-bit hash roughly equivalent: \\
- 128-bit AES -- SHA-256 \\
- 192-bit AES -- SHA-384 \\
- 256-bit AES -- SHA-512.

With CrypTool\index{CrypTool} v1.3.04 you can comprehend the birthday attack
\index{Birthday attack} on digital signatures: \\
using menu {\bf Indiv. Procedures \textbackslash{} 
Attack on the hashvalue of the digital signature}.

}  or \index{RIPEMD-160} RIPEMD-­160\footnote{%
RIPEMD-160, RIPEMD-128 and the optional extension RIPEMD-256 have object
identifiers defined by the ISO-identified organization TeleTrusT, both 
as hash algorithm and in combination with RSA.
RIPEMD-160 is also part of the ISO/IEC international standard 
ISO/IEC 10118-3:1998 on dedicated hash functions, together with 
RIPEMD-128 and SHA-1. 

Further details: \\
http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html \\
http://www.ietf.org/rfc/rfc2857.txt (``The Use of HMAC-RIPEMD-160-96 within ESP and AH'').
}).

The hash function procedure is as follows:\\ Rather than signing the actual
document, the sender now first calculates the hash value of the message and
signs this. The recipient also calculates the hash value of the message (the
algorithm used must be known), then verifies whether the signature sent with the
message is a correct signature of the hash value. If this is the case, the
signature is verified to be correct. This means that the message is authentic,
because we have assumed that knowledge of the public key does not enable you to
derive the secret key. However, you would need this secret key to sign messages
in another name.

Some digital signature schemes are based on asymmetric \emph{encryption}
procedures, the most prominent example being the RSA system, which can be
used for signing by performing the private key operation on the hash value
of the document to be signed.

Other digital signature schemes where developed exclusively for this
purpose, as the DSA (Digital Signature Algorithm), and are not directly
connected with a corresponding encryption scheme.

Both, RSA and DSA signature are discussed in more detail in the following
two sections. After that we go one step further and show how digital
signatures can be used to create the digital equivalent of ID cards. This
is called Public Key Certification.

% --------------------------------------------------------------------------
\subsection{RSA signatures}
\index{Signature!digital}
\index{RSA!signature}

\def\Mod#1{\ (\mbox{mod }#1)}
As mentioned in the comment at the end of \hyperlink{RSAproof}{section
  \ref{RSAproof}} it is possible to perform the RSA private and public key
operation in reverse order, i.~e.\ raising $M$ to the power of $d$ and then
to the power of $e \Mod{N}$ yields $M$ again. Based on this simple fact, RSA
can be used as a signature scheme.

The RSA signature $S$ for a message $M$ is created by performing the private
key operation:
$$ S \equiv M^d \Mod{N} $$
In order to verify, the corresponding public key operation is performed on
the signature $S$ and the result is compared with message $M$:
$$ S^e \equiv (M^d)^e \equiv (M^e)^d \equiv M \Mod{N}$$
If the result matches the message $M$, then the signature is accepted by the
verifier, otherwise the message has been tampered with, or was never signed
by the holder of $d$.

As explained above, signatures are not performed on the message itself, but
on a cryptographic hash value of the message. To prevent certain attacks
on the signature procedure (alone or in combination with encryption) it is
necessary to format the hash value before doing the exponentiation, as
described in the PKCS\#1 (Public Key Cryptography Standard \#1
\cite{PKCS1}). The fact that this standard had to be revised recently, after
being in use for several years, can serve as an example of how difficult it is
to get the details of cryptography right.

% --------------------------------------------------------------------------
\subsection{DSA signatures}
\index{Signature!digital}
\index{DSA!signature}

In August of 1991, the U.S. National Institute of Standards and Technology
(NIST\index{NIST}) proposed a digital signature algorithm (DSA), which was
subsequently adopted as a U.S. Federal Information Processing Standard (FIPS 186
\cite{FIPS186}). 

The algorithm is a variant of the ElGamal scheme. Its security is based on
the Discrete Logarithm Problem\index{Logarithm problem!discrete}. The DSA public and private key and its
procedures for signature and verification are summarised below.

\paragraph{Public Key}\strut\\
\begin{tabular}{l@{ }l}
$p$ & prime \\
$q$ & 160-bit prime factor of $p - 1$ \\
$g$ & $ = h^{(p-1)/q}  \mbox{ mod } p$, where $h < p - 1$ and
$h^{(p-1)/q} > 1  \Mod{p}$ \\
$y$ & $\strut \equiv  g^x  \mbox{ mod } p$ 
\end{tabular}

\emph{Remark:} Parameters $p,q$ and $g$ can be shared among a group of users.

\paragraph{Private Key}\strut\\
\begin{tabular}{l@{ }l}
$x < q$ (a 160-bit number) 
\end{tabular}

\paragraph{Signing}\strut\\
\begin{tabular}{l@{ }l}
$m$ & the message to be signed\\
$k$ & choose at random\index{Random}, less than $q$\\
$r$ & $= (g^k \mbox{ mod } p) \mbox{ mod } q$\\
$s$ & $= (k^{-1}(\mbox{SHA-1}(m) + xr)) \mbox{ mod } q$
\end{tabular}

\emph{Remark:}
\begin{itemize}
\item $(s,r)$ is the signature.
\item The security of the signature depends not only on the mathematical
  properties, but also on using a good random source\index{Random}  for $k$.
\item SHA-1 \index{SHA-1} is a 160-bit hash function.
\end{itemize}
\paragraph{Verifying}\strut\\
\begin{tabular}{l@{ }l}
$w$ & $= s^{-1}  \mbox{ mod } q$\\
$u_1$ & $= (\mbox{SHA-1}(m)w) \mbox{ mod } q$\\
$u_2$ & $= (rw)  \mbox{ mod } q$\\
$v$ & $= (g^{u_1}y^{u_2}) \mbox{ mod } p)  \mbox{ mod } q$\\

\end{tabular}

\emph{Remark:} If $v = r$, then the signature is verified.

While DSA was specifically designed, so that it can be exported from
countries regulating export of encryption soft and hardware (like the U.S.\ 
at the time when it was specified), it has been noted
\cite[p.~490]{Schneier1996ds}, that the operations involved in DSA can be
used to emulate RSA and ElGamal encryption.


% --------------------------------------------------------------------------
\subsection{Public key certification}
\index{Certification!public key}
\index{PKI}
The aim of public key certification is to guarantee the connection between a
public key and a user and to make it traceable for external parties. In cases in
which it is impossible to ensure that a public key really belongs to a
particular person, many protocols are no longer secure, even if the individual
cryptographic modules cannot be broken.


% --------------------------------------------------------------------------
\subsubsection{Impersonation attacks}\label{Impersonalisierungsattacke}
\index{Impersonation attack}
Assume Charlie has two pairs of keys (PK1, SK1) and (PK2, SK2), where SK denotes
the secret key and PK the public key. Further assume that he manages to palm off
PK1 on Alice as Bob's public key and PK2 on Bob as Alice's public key (by
falsifying a public key directory).

Then he can attack as follows:
\begin{itemize}
    \item Alice wants to send a message to Bob. She encrypts it using PK1
because she thinks that this is Bob's public key. She then signs the message
using her secret key and sends it.
    \item Charlie intercepts the message, removes the signature and decrypts the
message using SK1. If he wants to, he can then change the message in any way he
likes. He then encrypts the message again, but this time using Bob's genuine
public key, which he has taken from a public key directory, signs the message
using SK2 and forwards it to Bob.
    \item Bob verifies the signature using PK2 and will reach the conclusion
that the signature is correct. He then decrypts the message using his secret
key.
\end{itemize}

In this way Charlie can listen in on communication between Alice and Bob and
change the exchanged messages without them noticing. The attack will also work
if Charlie only has one pair of keys.

Another name for this type of attack is \index{Man-in-the-middle attack} ``man-­in-­the-­middle attack''. Users are promised
protection against this type of attack by public­key
certification, which is intended to guarantee the
\index{Authenticity} authenticity of public keys. The most common
certification method is the X.509 standard.

% --------------------------------------------------------------------------
\subsubsection{X.509 certificate}
\index{X.509} 
Each participant who wants to have an X.509 certificate (\cite{X.509})
verifying that his public key belongs to a real person consults what is
known as a \index{Certification authority (CA)} certification authority
(CA)\footnote{%
Often called trust center, if the certificates are not only offered
to a closed user group.
}. 
He proves his identity to this CA (for example by showing his ID). 
The CA then issues him an electronic document (certificate) which 
essentially contains the name of the certificate-holder and the name
of the CA, the certificate-holder's public key and the validity period
of the certificate. The CA then signs the certificate using its secret key.

Anyone can now use the CA's public key to verify whether a certificate is
falsified. The CA therefore guarantees that a public key belongs to a particular
user.

This procedure is only secure as long as it can be guaranteed that the CA's
public key is correct. For this reason, each CA has its public key certified by
another CA that is superior in the hierarchy. In the upper hierarchy level there
is usually only one CA, which can of course then have its key certified by
another CA. It must therefore transfer its key securely in another way. In the
case of many software products that work with certificates (such as the
Microsoft and Netscape Web browsers), the certificates of these root CAs are
permanently embedded in the program right from the start and cannot be changed
by users at a later stage. However, (public) CA keys, in particularly those of
the root entity, can also be secured by means of making them available publicly.

\begin{thebibliography}{99999}
\addcontentsline{toc}{subsection}{Bibliography}

\bibitem[Schneier1996]{Schneier1996ds} \index{Schneier 1996} 
    Bruce Schneier, \\
    Applied Cryptography, Protocols, Algorithms, and Source Code in C, \\
    Wiley, 2nd edition, 1996.


\bibitem[PKCS1]{PKCS1} RSA Laboratories\\ 
    \index{PKCS\#1} \index{RSA Laboratories}
    PKCS \#1 v2.1 Draft 3: RSA Cryptography Standard, April 19, 2002.


\bibitem[X.509v3]{X.509v3} ITU-T\\ 
    \index{X.509} \index{ITU-T} \index{ISO/IEC 9594-8}
    X.509 (1993) Amendment 1: Certificate Extensions, The Directory
    Authentication Framework,\\ 
    International Telecommunication Union, Geneva, Switzerland, July 1995\\
    (equivalent to Amendment 1 to ISO/IEC 9594-8).


\bibitem[FIPS180-2]{FIPS180-2} U.S. Department of Commerce/N.I.S.T. 
    \index{FIPS180-2} \\
    Secure Hash Standard (SHS), August 1, 2002.\\
    (FIPS 180-2 will supersede FIPS 180-1 beginning February 1, 2003.)


\bibitem[FIPS186]{FIPS186} U.S. Department of Commerce/N.I.S.T.
    \index{FIPS186} \\
    Entity authentication using public key cryptography, February 18, 1997.\\
    No more valid.
    
\bibitem[FIPS186-2]{FIPS186-2} U.S. Department of Commerce/N.I.S.T. 
    \index{FIPS186-2} \\
    Digital Signature Standard (DSS), January 27, 2000.\\
    Change Note: October 5, 2001.\\
    http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf
\bibitem[X.509]{X.509}
    \index{X.509}
    ITU-T Recommendation X.509 (1997 E): Information Technology -- 
    Open Systems Interconnection -- The Directory: Authentication Framework, June 1997.

\end{thebibliography}

% Local Variables:
% TeX-master: "../script-en.tex"
% End:
