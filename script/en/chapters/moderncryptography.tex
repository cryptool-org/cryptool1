% $Id$
\setcounter{theorem}{0}
\setcounter{definition}{0}

\newcommand{\NT}{\vspace*{0.2\baselineskip}\\}
%\newcommand{\VT2}{\vspace*{0.1\baselineskip}\\}
\newcommand{\HZ}{\vspace*{0.5\baselineskip}}
\newcommand{\R}{\text{I}\!\text{R}}
\newcommand{\N}{\text{I}\!\text{N}}
\newcommand{\Q}{\text{Q}\!\!\!\text{l}\,\,}
\newcommand{\C}{\text{C}\!\!\!\text{l}\,\,}
\newcommand{\K}{\text{I}\!\text{K}}
\newcommand{\Z}{\mathbf{\mathbb{Z}}}
%--------------------------------------- matheScript-Zeichen definieren
\newcommand{\fs}{\mathscr{F}}  
\newcommand{\es}{\mathscr{E}}  
\newcommand{\cs}{\mathscr{C}}  
\newcommand{\gs}{\mathscr{G}}
\newcommand{\is}{\mathscr{I}}
\newcommand{\os}{\mathscr{O}}
\newcommand{\ks}{\mathscr{K}}
\newcommand{\qs}{\mathscr{Q}}
\newcommand{\us}{\mathscr{U}}
\newcommand{\hs}{\mathscr{H}}
\newcommand{\ps}{\mathscr{P}}
\newcommand{\as}{\mathscr{A}}
\newcommand{\rs}{\mathscr{R}}
\newcommand{\bs}{\mathscr{B}}
%-------------------------------------
\newcommand{\PG}{\text{I}\!\text{P}}
\newcommand{\carre}{\square}
\newcommand{\ncarre}{/\negthickspace\negthickspace\square}
\newcommand{\ncarreq}{{\ncarre}_q}
\newcommand{\ncarree}{/\negthickspace\negthickspace\negthickspace\square}
\newcommand{\ncarrepi}{{\ncarre}_{p^i}}
\newcommand{\mc}[1]{{\cal #1}}
\newcommand{\Char}{\text{char}}
\newcommand{\Aut}{\text{Aut}}
\newcommand{\Fix}{\text{Fix}}
\newcommand{\Syl}{\text{Syl}}
\newcommand{\Bild}{\text{Bild}}
\newcommand{\ggt}{{\rm gcd}}
\newcommand{\kgv}{\text{kgV}}
\newcommand{\Id}{\text{Id}}
\newcommand{\nqcarre}{{\ncarre}_{q^2}}
%\newcommand{\mod}{{\rm mod~}}
%\normalsize
%\parindent = 0pt
%\setlength{\textwidth}{140mm}
%\setlength{\textheight}{216mm}


% \theorembodyfont{\} 
% \newtheorem{Bsp}{Beispiel}[section]

% {\theorembodyfont{\em}
%                  \newtheorem{Def}[Bsp]{Definition} }

% \theorembodyfont{\em} 
% \newtheorem{Hilf}[Bsp]{Hilfssatz}

%\theorembodyfont{\em} 
% \newtheorem{Lem}[Bsp]{Lemma}

%\theorembodyfont{\em} 
% \newtheorem{Kor}[Bsp]{Korollar}

%\theorembodyfont{\em}
% \newtheorem{Folg}[Bsp]{Folgerung}

%\theorembodyfont{\em}
%  \newtheorem{Satz}[Bsp]{Satz}

% \theoremstyle{break} 
% {\theorembodyfont{\em} 
% \newtheorem{Theo}[Bsp]{Theorem}}                 
% In diesem Stil wird nach dem Theoremkopf ein Zeilenumbruch vorgenommen.

% \theoremstyle{break} 
% {\theorembodyfont{\em} 
% \newtheorem{Haupt}[Bsp]{Hauptsatz}}                 
% In diesem Stil wird nach dem Theoremkopf ein Zeilenumbruch vorgenommen.
% \newenvironment{Beweis}[1]
%   {\textbf{Beweis #1} \\}
%   {\hfill$\Box$ \\}

\setlength{\fboxrule}{.4pt}
\setlength{\fboxsep}{4pt}


\newpage
%********************************************************************
\hypertarget{Chapter_ModernCryptography}{}
\chapter[The Mathematical Ideas behind Modern Cryptography]
        {The Mathematical Ideas behind Modern Cryptography\footnotemark}
\footnotetext{%
    \index{NT, Learning Tool for Number Theory}%
    \index{Educational tool NT}%
    With the educational tool for number theory {\bf NT} you can apply
    some of the methods introduced here (RSA, Rabin, DH, ElGamal)
    (see learning unit 4.2 and 4.3, pages 9-17/17).\\
    NT can be called in CT1\index{CrypTool 1} via the menu path
    {\bf Indiv. Procedures \textbackslash{} Number Theory Interactive
    \textbackslash{} Learning Tool for Number Theory}.
    See appendix \ref{s:appendix-Learn-NT}.\\
    You can find according functions within the programs CT1,
    CT2\index{CrypTool 2} and JCT\index{JCrypTool}: see the list of the included
    functions within appendix \ref{s:appendix-menu-overview-CT1}, 
    \ref{s:appendix-template-overview-CT2} and
    \ref{s:appendix-function-overview-JCT}.
}
\label{Chapter_ModernCryptography}
%********************************************************************
(Oyono R. / Esslinger B./ Schneider J., Sep. 2000; 
            Updates Nov. 2000, Feb. 2003, Apr. 2007, Mar. 2010, Jan. 2013)

%\vskip +30 pt
\begin{ctsquote}
   I don't know if its getting better, if we change it,\\
   but I know, that we have to change it, if it should become better.%TODO - Rest von German
\caption[Georg Christoph Lichtenberg]{Georg Christoph Lichtenberg\footnotemark}
\end{ctsquote}
\footnotetext{%
  Georg Christoph Lichtenberg\index{Lichtenberg, Georg Christoph}, 
  German writer and physicist (1742-1799),\\ 
  (also see: \url{http://en.wikipedia.org/wiki/Georg\_Christoph\_Lichtenberg})
}

%--------------------------------------------------------------------
\hypertarget{OneWayFunktion1}{}
\section{One way functions with trapdoor and complexity classes}
\label{OneWayFunktion1}
%--------------------------------------------------------------------
\index{Cryptography!modern} \index{One way function}
A {\bf one way function} is a function that can be calculated 
efficiently, but whose inverse is extremely complicated and practically 
impossible to calculate.\par

To put it more precisely:  A one way function is a mapping $ f $ from a set $ X 
$ to a set $ Y, $ such that $ f(x) $ can be calculated easily for each element $ 
x $ of $ X $, whereas for (almost) every $ y $ from $ Y $  it is practically 
impossible to find an inverse image $ x $ (i.e. an $ x $ where $ f(x)=y $).\par

An everyday example of a one way function is a telephone book: the function to 
be performed is to assign a name to the corresponding telephone number. This can 
be done easily due to the fact that the names are sorted alphabetically. 
However, the inverse function - assigning a name to a given number - is 
obviously difficult if you only have a telephone book available. \par

One way functions play a decisive role in cryptography. Almost all cryptographic 
terms can be rephrased using the term one way function. Let's take for example 
public key encryption \index{Encryption!public key}\index{Encryption!asymmetric} 
(asymmetric cryptography):\par

Each subscriber $ T $ to the system is assigned a private \index{Key!private} 
\index{Key!public} key $ d_T $   and what is known as a public key $ e_T $. 
These keys must have the following property (public key property):\\
For an opponent who knows the public key $ e_T $, it is practically impossible 
to determine the private key  $ d_T $.\par

In order to construct useful public key procedures, therefore, we look for a 
one way function that is ``easy'' to calculate in one direction {}, but 
is ``difficult'' (practically impossible) to calculate in the other 
direction, provided that a particular piece of additional information 
\index{One way function!with trapdoor } (trapdoor) is not available. This 
additional piece of information allows the inverse to be found efficiently. Such 
functions are called {\bf trapdoor one way functions}. In the above case, $ d_T 
$ is the trapdoor information. \par

In this process, we describe a problem as ``easy'' if it can be solved in 
\index{Runtime!polynomial} \index{Polynomial}polynomial time as a function of the length of the 
input. If the length of the input is $ n $ bits, then the time for calculating 
the function is proportional to $ n^{a}, $ where $ a $  is a constant. We say 
that the \index{Complexity} complexity of such problems is $ O(n^{a}) $
[Landau- or Big-O notation]. 

If you compare two functions  $ 2^n $  and   $ n^{a} $,  where $ a $  is a
constant, then there always exists a value for  $ n $,  from which for all
further  $ n $  applies: $ n^{a}  <  2^n $. 
The function  $ n^{a} $  has a lower complexity.    
Sample: for $ a=5 $ the following applies: from the length $ n=23 $, $ 2^n$
is greater than $n^5 $; for further $ n $  $ 2^n $ clearly increases more
quickly \
[($ 2^{22}= 4,194,304 $, $ 22^5= 5,153,632 $), \
 ($ 2^{23}= 8,388,608 $, $ 23^5= 6,436,343 $), \
 ($ 2^{24}=16,777,216 $, $ 24^5= 7,962,624 $)].\par 

The term ``practically impossible'' is slightly less precise. In 
general, we can say that a problem cannot be solved \index{Runtime!efficient} 
efficiently, if the time required to solve it increases more quickly than the 
polynomial\index{Polynomial} time as a function of the size of the input. If, for example, the 
length of the input is $ n $  bits and the time required for calculating the 
function is proportional to $ 2^n $, then the following currently applies: the 
function practically cannot be calculated for $n > 80$.

In order to develop a public key procedure that can be implemented in practice, 
it is therefore necessary to discover a suitable trapdoor one way function.\par

In order to tidy things up among this confusing multitude of possible problems 
and their complexities, we group problems with similar complexities into 
classes.

The most important complexity classes are the classes \textbf{P} and 
\textbf{NP}: 

\begin{itemize}

    \item The class \textbf{P}: This class contains those problems that can be 
solved in a polynomial \index{Polynomial} amount of time.
    
		\item The class \textbf{NP}: The definition of this class doesn't look at
		the time required to solve a problem, but rather at the time required to
		verify a given solution. The class \textbf{NP} consists of those problems
		for which a given solution can be verified in a polynomial \index{Polynomial} amount of time.
		Hereby, the term \textbf{NP} ``non-deterministic'' means polynomial and is
		based on a calculation model, i.e. on a computer that only exists in theory
		and can ``guess'' correct solutions non-deterministically then verify them
		in polynomial time.

\end{itemize}

The class \textbf{P} is contained in the class \textbf{NP}. A well-known 
unsolved problem is the question whether or not $ \textbf{P} \neq \textbf{NP} $ 
is true, i.e. whether or not \textbf{P} is a true subset. An important property 
of the class \textbf{NP} is that it also contains what are known as ``\textbf{NP}-complete''
problems. These are problems that represent the 
class \textbf{NP} as follows: If a ``good'' algorithm for such a 
problem exists, then ``good'' algorithms exist for all problems from 
\textbf{NP}. In particular: if \textbf{P} only contained one complete problem, 
i.e. if a polynomial \index{Polynomial} solution algorithm existed for this problem, then 
\textbf{P}would be equal to \textbf{NP}. In this sense, the \textbf{NP}-complete 
problems are the most difficult problems in \textbf{NP}.

Many cryptographic protocols are formed in such a way that the ``good''
subscribers only have to solve problems from \textbf{P}, whereas a 
perpetrator is faced with problems from \textbf{NP}.

Unfortunately, we do not yet know whether one way functions actually exist. 
However, we can prove that one way functions exist if and only if $ \textbf{P} 
\neq \textbf{NP} $ \cite[S.63]{mc:Balcazar1988}.\\

\vskip +3pt
Some mathematicians have again and again claimed to have proven this equivalence, 
but so far the claims have always turned out to be false \cite{mc:Hesselink2001}.

A number of algorithms have been suggested for public key procedures\index{Cryptography!public key}. In many 
cases - although they at first appeared promising - it was discovered that they 
could be solved polynomially\index{Polynomial}. The most famous failed applicant is the knapsack 
with trapdoor, suggested by Ralph Merkle \cite{mc:Merkle1978}.

%\newpage
\vskip +20 pt
%--------------------------------------------------------------------
\section{Knapsack problem as a basis for public key procedures}%
\index{Cryptography!public key}
%--------------------------------------------------------------------

%--------------------------------------------------------------------
\subsection{Knapsack problem}
\index{Knapsack}

You are given $ n $ objects $ G_1, \dots, G_n $ with the weights $ g_1, \dots 
g_n $ and the values $w_1, \cdots, w_n. $ The aim is to carry away as much as 
possible in terms of value while restricted to an upper weight limit $ g $. You 
therefore need to find a subset of $ \{ G_1, \cdots,G_n\}, $ i.e. $ \{G_{i_1}, 
\dots ,G_{i_k} \}, $ so that $ w_{i_1}+ \cdots +w_{i_k} $ is maximised under the 
condition $  g_{i_1}+ \cdots +g_{i_k} \leq g. $ \par
Such questions are called {\bf NP}-complete problems (not \index{Runtime!not polynomial NP} deterministically polynomial\index{Polynomial}) that are difficult to 
calculate.\index{Knapsack}

A special case of the knapsack problem is:\\
Given the natural numbers $ a_1, \dots, a_n $   and $ g .$,
find $ x_1, \dots, x_n \in \{ 0,1\} $  where $ g = \sum_{i=1}^{n}x_i a_i $  
(i.e. where $ g_i = a_i = w_i $ is selected). This problem is also called a  
{\bf 0-1 knapsack problem} and is identified with $ K(a_1, \dots, a_n;g) $.\\

Two 0-1 knapsack problems  $ K(a_1, \dots, a_n;g) $   and  $ K(a'_1, \dots, 
a'_n;g') $  are called congruent if two co-prime\index{Number!co-prime}
numbers $ w $ and $ m $ exist in such a way that
\begin{enumerate}
    \item $ m > \max \{ \sum_{i=1}^n a_i , \sum_{i=1}^n a'_i \}, $

    \item $ g \equiv wg' \mod m, $

    \item $ a_i \equiv w a'_i \mod m $ for all $ i=1, \dots, n.$

\end{enumerate}
 
\begin{remark}{:}\\
Congruent 0-1 knapsack problems have the same solutions.
No quick algorithm is known for clarifying the question as to whether two 0-1
knapsack problems are congruent.
\end{remark}

A 0-1 knapsack problem can be solved by testing the $ 2^n $   possibilities for 
$ x_1, \dots, x_n $. The best method requires $ O(2^{n/2}) $  operations, which 
for $ n=100 $  with $ 2^{100} \approx 1.27 \cdot 10^{30} $  and  $ 2^{n/2} 
\approx 1.13 \cdot 10^{15} $ represents an insurmountable hurdle for computers.
However, for special $ a_1, \dots, a_n $   the solution is quite easy to find, 
e.g. for $ a_i = 2^{i-1}. $  The binary representation of $ g $ immediately 
delivers $ x_1, \dots, x_n$. In general, the a 0-1 knapsack problem can be 
solved easily if a \index{Permutation} permutation\footnote{%
A permutation\index{Permutation} $\pi$ of the numbers $1, \dots, n$ is a change in the order in which these numbers are listed. For example, a permutation $\pi$ of $(1,2,3)$ is $(3,1,2),$ i.e. $\pi(1) = 3$, $\pi(2) =1$ and $\pi(3) = 2$.} 
$ \pi $  of $ 1, \dots, n $  exists with $ a_{\pi (j)} > \sum_{i=1}^{j-1} 
a_{\pi(i)} $. If, in addition, $ \pi $ is the identity, i.e. $ \pi(i)=i $ for $ 
i=1,2,\dots,n, $ then the sequence $ a_1, \dots , a_n $ is said to be 
super-increasing.
Crypto procedure~\ref{knapsackalgo} solves the knapsack problem with a super-increasing 
sequence in the time of $ O(n). $
\begin{cryptoprocedure}
\begin{tabbing}
\hspace*{0.5cm} \= \hspace*{0.5cm} \= \hspace*{0.5cm} \= \kill
\>{\bf for} $ i=n $ {\bf to} 1 {\bf do} \\
\>\> {\bf if} $ T\geq a_i $ {\bf then}\\
\>\> \> $ T:=T-s_i $ \\
\>\>\> $ x_i:=1 $ \\
\>\> {\bf else} \\
\>\>\> $ x_i:=0 $ \\
\>{\bf if} $ T=0 $ {\bf then} \\
\>\> $ X:=(x_1, \dots, x_n) $ is the solution. \\
\>{\bf else} \\
\>\> No solution exists.
\end{tabbing}
\caption{Solving knapsack problems with super-increasing weights}
\label{knapsackalgo}
\end{cryptoprocedure}

%--------------------------------------------------------------------
\subsection{Merkle-Hellman knapsack encryption}
%--------------------------------------------------------------------
\index{Hellman, Martin} \index{Merkle, Ralph} 

In 1978, Merkle and Hellman 
\cite{mc:Merkle1978} \index{Encryption!Merkle-Hellman} specified a public key 
encryption procedure that is based on ``defamiliarizing'' the easy 0-1 
knapsack problem with a super-increasing sequence into a congruent one with a 
super-increasing sequence. It is a block ciphering that ciphers an $n$-bit 
plaintext each time it runs, see crypto procedure~\ref{merklehellmanproc} for the details.
\index{Knapsack!Merkle-Hellman}

\begin{cryptoprocedure}
Let $ (a_1, \dots, a_n) $ be super-increasing. Let $ m $ and $ w $ be two
co-prime\index{Number!co-prime}
numbers with $ m > \sum_{i=1}^{n} a_i $ and $ 1\leq w \leq m-1. $ Select 
$\bar{w} $ with $ w \bar{w} \equiv 1 \mod m $ the modular inverse of $ w $ and 
set $ b_i:= wa_i \mod m, $ $ 0\leq b_i < m $ for $ i=1, \dots ,n, $ and verify 
whether the sequence $ b_1, \dots b_n $ is not super-increasing. A permutation $ 
b_{\pi (1)}, \dots , b_{\pi(n)} $ of  $ b_1, \dots , b_n $ is then published and 
the inverse permutation $ \mu $ to $ \pi $ is defined secretly. A sender writes 
his/her message in blocks $ (x_1^{(j)}, \dots, x_n^{(j)}) $ of binary numbers $ 
n $ in length, calculates
\[ g^{(j)}:= \sum_{i=1}^n x_{i}^{(j)} b_{\pi(i)} \]
and sends $ g^{(j)}, (j=1,2, \dots). $\par
The owner of the key calculates
\[ G^{(j)}:=\bar{w} g^{(j)} \mod m ,\quad 0 \leq G^{(j)} < m \]
and obtains the $ x_{\mu(i)}^{(j)} \in \{ 0,1\} $ (and thus also the $ x_i^{(j)} 
$) from
\begin{eqnarray*}
G^{(j)} & \equiv & \bar{w} g^{(j)} = \sum_{i=1}^n x_i^{(j)} b_{\pi (i)} \bar{w} 
\equiv \sum_{i=1}^n x_i^{(j)} a_{\pi (i)} \mod m \\
& = & \sum_{i=1}^n x_{\mu (i)}^{(j)} a_{\pi (\mu (i))} = \sum _{i=1}^n x_{\mu 
(i)}^{(j)} a_i \mod m, 
\end{eqnarray*}
by solving the easier 0-1 knapsack problems $ K(a_1,\dots,a_n;G^{(j)}) $ with 
super-increasing sequence $ a_1, \dots,a_n $.
\caption{Merkle-Hellman (based on knapsack problems)}
\label{merklehellmanproc}
\end{cryptoprocedure}

In 1982, \index{Shamir, Adi} Shamir \cite{mc:Shamir1982} specified an algorithm for 
breaking the system in polynomial \index{Polynomial} time without solving the general knapsack 
problem. Len \index{Adleman, Leonard} Adleman \cite{mc:Adleman1982} and Jeff 
Lagarias \index{Lagarias, Jeff} \cite{mc:Lagarias1983} specified an algorithm for 
breaking the twice iterated Merkle-Hellman knapsack encryption procedure in 
polynomial time. Ernst Brickell \index{Brickell, Ernst} \cite{mc:Brickell1985} then 
specified an algorithm for breaking multiply iterated Merkle-Hellman knapsack 
encryption procedures in polynomial time. This made this procedure unsuitable as 
an encryption procedure. It therefore delivers a one way function whose trapdoor 
information (defamiliarization of the 0-1 knapsack problem) could be discovered 
by an eavesdropper.


%--------------------------------------------------------------------
\section{Decomposition into prime factors as a basis for public key
procedures}\index{Prime factor!decomposition}


%--------------------------------------------------------------------
\hypertarget{RSAVerfahren}{}
\subsection[The RSA procedure]
{The RSA procedure\footnote{%
Please compare chapters \ref{rsabeweis}, ff.
}$^,$\footnote{%
Using CT1\index{CrypTool 1} you can gain practical experience
with the RSA procedure via the menu {\bf Indiv.Procedures \textbackslash{} 
RSA Cryptosystem \textbackslash{} RSA Demonstration}.\\
You can find RSA also in CT2\index{CrypTool 2} and JCT\index{JCrypTool}.
}
}
% LateX-Learnings: Mit \footnotemark statt \footnote
% stand der höhere Index unten zweimal (oben ok).
%
%  {The RSA procedure\footnotemark$^,$\footnotemark}
%  \footnotetext{
%  Please compare chapters \ref{rsabeweis}, ff.
%  }
%  \footnotetext{
%  Using CrypTool\index{CrypTool} you can gain practical experience
%  with the RSA procedure via the menu {\bf Indiv.Procedures \textbackslash{} 
%  RSA Cryptosystem \textbackslash{} RSA Demonstration}.
%  }
%  
%   in the article ``Introduction to Elementary Number Theory with Examples'',
%   chapter~\ref{patternsandstructures}
%   \hyperlink{RSABeweis}{Beweis des RSA-Verfahrens mit Euler-Fermat}
\index{RSA} \label{rsaverfahren}

As early as 1978, R. \index{Rivest, Ronald} Rivest, \index{Shamir, Adi} 
A. Shamir, \index{Adleman, Leonard} L. Adleman \cite{mc:RSA1978} introduced 
the most important asymmetric cryptography procedure to date.  \par

\begin{cryptoprocedure}
\textbf{Key generation:} \vskip + 5pt

Let $ p $ and $ q $ be two different prime numbers and $ N = pq$. Let 
$ e $ be any prime number relative to $ \phi (N) $
\index{Prime number!relative prime}\index{Relative prime},
i.e. $ \ggt (e,\phi (N))=1. $\index{gcd}
Using the Euclidean algorithm, 
we calculate the natural number  $ d < \phi (N), $ such that
\[ ed \equiv 1 \mod \phi (N). \]
whereby $ \phi $ is the {\bf Euler phi Function}. 

The output text is divided into blocks and encrypted, whereby each block has a 
binary value $ x^{(j)} \leq N $. \vskip + 5 pt

\textbf{Public key:}
\[ N,e. \]
\textbf{Private key:}
\[ d. \]
\textbf{Encryption:}
\[ y= e_{T} (x) = x^{e} \mod N.\]
\textbf{Decryption:}
\[ d_{T} (y) = y^d \mod N. \]
\caption{RSA (based on the factorization problem)}
\label{rsaproc}
\index{Factorization!factorization problem}
\index{Euler!(phi) function}
\end{cryptoprocedure}

\begin{remark}{:}\\
The Euler phi function is defined as: $ \phi (N)$ is the number of natural 
numbers that do not have a common factor with $ N $ {} $ x \leq N. $
Two natural numbers $ a $ and $ b $ are co-prime\index{Number!co-prime} if 
$ \ggt (a,b)=1. $ 

For the Euler phi function it holds that: 
\[
\phi (1)=1, \phi(2)=1,
\phi(3)=2, \phi (4)=2, \phi(6)=2, \phi (10)= 4, \phi (15)=8.
\]
For example, $ \phi (24)=8, $ because
\[
|\{ x <24 : \ggt (x,24) =1 \}| =|\{1,5,7,11,13,17,19,23\}|.
\]
If  $ p $ is a prime number, then $ \phi (p)= p-1. $ \\
If we know the various prime factors $ p_1, \dots , p_k $ of $ N, $ then 
\[
\phi(N) = N \cdot (1-\frac{1}{p_1}) \,
\cdots \, (1-\frac{1}{p_k}).\footnote{%
Further formulas for the Euler phi function are in
chapter~\ref{L-Euler-Function} ``\nameref{L-Euler-Function}''.
}
\]
Table~\ref{phi15} gives the values up to $15$. 
In the case of $ N=pq $, 
\[
\phi (N)= pq(1-1/p)(1-1/q) = p(1-1/p)q(1-1/q)=(p-
1)(q-1).
\]
\end{remark}

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|l|}\hline
$n$ & $\phi (n) $ & The natural numbers that are co-prime\index{Number!co-prime}
to $ n $ and less than $ n. $ \\ \hline
1 & 1 & 1  \\
2 & 1 & 1 \\
3 &  2 & 1, 2 \\ 
4 &  2 & 1, 3 \\ 
5 &  4 & 1, 2, 3, 4 \\ 
6 &  2 & 1, 5 \\ 
7 &  6 & 1, 2, 3, 4, 5, 6 \\ 
8 &  4 & 1, 3, 5, 7 \\ 
9 &  6 & 1, 2, 4, 5, 7, 8 \\ 
10 &  4 & 1, 3, 7, 9 \\ 
15 &  8 & 1, 2, 4, 7, 8, 11, 13, 14 \\ \hline
\end{tabular}
\end{center}
\caption{Euler phi function}
\label{phi15}
\end{table}

The function $ e_T $  is a one way function whose trapdoor information is the 
decomposition into primes of $ N $.

At the moment, no algorithm is known that can factorize two prime numbers 
sufficiently quickly for extremely large values (e.g. for several hundred 
decimal places). The quickest algorithms known today
\cite{mc:4Stinson1995}\index{Stinson 1995} 
factorize a compound whole number $ N $ in a time period proportional to $ L(N)= 
e^{\sqrt{\ln (N) \ln (\ln (N))}}. $ Some example values can be found in 
table~\ref{lnvalues}.
\begin{table}[ht]
\begin{center}
\begin{tabular}{|l||l|l|l|l|l|l|}\hline
$N$ & $ 10^{50} $ & $ 10^{100} $ & $ 10^{150} $ & $ 10^{200} $ & $ 10^{250} $ & 
$ 10^{300} $ \\ \hline
$L(N)$ & $ 1.42 \cdot 10^{10} $ &  $ 2.34  \cdot 10^{15} $ &  $ 3.26 \cdot 
10^{19} $ &  $ 1.20 \cdot 10^{23} $ &  $ 1.86 \cdot 10^{26} $ &  $ 1.53 \cdot 
10^{29} $ \\ \hline
\end{tabular}
\end{center}
\caption{$L(N)$ value table [Factorization effort related to the modul length]}
\label{lnvalues}
\end{table}

To this date, it has not been proved that the problem of breaking RSA is 
equivalent to the factorization problem. Nevertheless, it is clear that
the RSA procedure will no longer be safe if the factorization problem is
``solved''.\footnote{%
In 2000 the authors assumed that values of the order magnitude $ 100 $ to $ 200 $
decimal places are currently safe. They estimates that the current computer
technology indicates that a number with $100$ decimal places could be
factorized in approximately two weeks at justifiable costs, and using an 
expensive configuration (e.g. of around 10 million US dollars), a number with 
$150$ decimal places could be factorized in about a year, and a $200$-digit
number should remain impossible to factorize for a long time to come, unless
there is a mathematical breakthrough. However, you can never be sure that
there won't be a mathematical breakthrough tomorrow.\\
How easy it is to guess the future wrong is shown by the
\hyperlink{RSA-200-chap3}{factorization of RSA-200} 
(see chapter \ref{nt:NoteFactorization}) -- completely without a
``mathematical breakthrough''.}




%--------------------------------------------------------------------
\subsection{Rabin public key procedure (1979)}

The Rabin\index{Rabin, Michael O.} public key procedure\index{Rabin!public key
procedure} (crypto procedure~\ref{rabinproc}) has been shown to be equivalent to
breaking the factorization problem. 
Unfortunately, this procedure is susceptible to chosen-ciphertext attacks.
\index{Attack!chosen-ciphertext}
\begin{cryptoprocedure}
Let $ p $ and $ q $ be two different prime numbers with $ p,q\equiv 3 \mod 4 $ 
and $ n = pq.$ Let $ 0\leq B \leq n-1.$ \\
\textbf{Public key:}
\[ e=(n,B). \]
\textbf{Private key:}
\[ d=(p,q). \]
\textbf{Encryption:}
\[ y= e_{T} (x) = x(x+B) \mod n.\]
\textbf{Decryption:}
\[ d_{T} (y) = \sqrt{y + B^2/4} -B/2 \mod n. \]
\caption{Rabin (based on the factorization problem)}
\label{rabinproc}
\end{cryptoprocedure}

Caution:
Because $ p,q \equiv 3 \mod 4 $  the encryption is easy to calculate (if the key 
is known). This is not the case for $ p \equiv 1 \mod 4. $ In addition, the 
encryption function is not injective: There are precisely four different source 
codes that have $ e_T(x) $  as inverse image: $ x,-x-B,\omega (x+B/2)-B/2, -
\omega(x+B/2)-B/2, $ where $ \omega $  is one of the four roots of unity. The 
source codes therefore must be redundant for the encryption to remain unique!

Backdoor information is the decomposition into prime numbers of $ n = pq. $ 





\vskip +20 pt
%--------------------------------------------------------------------
\hypertarget{HT-Discrete-Logarithm-as-Basis}{}
\section[The discrete logarithm as basis for public key procedures]
           {The discrete logarithm as basis for public key procedures\footnotemark}
\footnotetext{%
    \index{NT, Learning Tool for Number Theory}%
    \index{Educational tool NT}%
    With the educational tool for number theory {\bf NT} you can play with the
    distribution of the discrete logarithm values and apply Shank's
    baby-step-giant-step method:
    See learning units 6.1-6.3, pages 1-6/6.\\
    NT can be called in CT1\index{CrypTool 1} via the menu path
    {\bf Indiv. Procedures \textbackslash{} Number Theory Interactive
    \textbackslash{} Learning Tool for Number Theory}.
    See appendix \ref{s:appendix-Learn-NT}.
}
\label{L-Discrete-Logarithm-as-Basis}
\index{Discrete logarithm}\index{Logarithm problem!discrete}
Discrete logarithms form the basis for a large
number of algorithms for public-key procedures.

%--------------------------------------------------------------------
\subsection{The discrete logarithm in \texorpdfstring{$ \Z_p $}{Zp}}
\label{L_Discrete_Logarithm}  %Die Kapitelnr von \label wird per per \ref geholt.

Let $ p $ be a prime number and let $ g \in \Z_p^\ast=\{0,1,\ldots,p-1\} $. Then 
the discrete exponential function base $ g $  is defined as
\[ e_g : k \longrightarrow y:=g^k \mod p, \quad 1\leq k \leq p-1. \]
The inverse function is called a discrete logarithm function $ \log_g $; the 
following holds:
\[ \log_g (g^k) =k. \]
\index{Exponential function!discrete} The problem of the discrete logarithm (in 
$ \Z_p^\ast$) is understood to be as follows:
\[ {\rm Given~ } p,g {\rm ~and~ } y, {\rm~determine~} k {\rm ~such~that~ } 
y=g^k \mod p {\rm .}\]
It is much more difficult to calculate the discrete logarithm than to evaluate 
the discrete exponential function (see chapter \ref{MultOrdPrimitveRoot}).
Table~\ref{dlogprocs} lists several procedures for calculating the discrete logarithm 
and their complexity \cite{mc:4Stinson1995}\index{Stinson 1995}.
\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|}\hline
Name                 &        Complexity \\ \hline \hline
Baby-step-giant-step &         $ O(\sqrt{p}) $ \\ \hline
Silver-Pohlig-Hellman    &    polynomial in $ q, $ the greatest \\
&  prime factor of $ p-1. $ \\ \hline
Index-Calculus &             $ O(e^{(1+o(1)) \sqrt{\ln (p) \ln (\ln (p))}}) $ \\ 
\hline
\end{tabular}
\end{center}
\caption{Procedures for calculating the discrete logarithm over $\Z_p^\ast$}
\label{dlogprocs}
\index{Silver} \index{Pohlig, S. C.} \index{Hellman, Martin}
\index{Baby-step-giant-step}
\end{table}

The current record\index{Logarithm problem!record} (as of April 2007) for calculating discrete logarithms was
established in February 2007 by the group Kleinjung, Franke and Bahr at
University of Bonn.\footnote{%
   \url{http://www.nabble.com/Discrete-logarithms-in-GF(p)-----160-digits-t3175622.html}}
Kleinjung calculated the discrete logarithm modulo a 160 digit prime number $p$
and generator $g$:
$$
\begin{array}{r@{\:}c@{\:}l}
p & = & \lfloor 10^{159}\pi\rfloor + 119849 \\
  & = & 314159265358979323846264338327950288419716939937510582097494 \\
  &   & 459230781640628620899862803482534211706798214808651328230664 \\
  &   & 7093844609550582231725359408128481237299\\
g & = & 2
\end{array}
$$
The discrete logarithms $k$ of the following integer $y$ was
determined:\footnote{The integer $y$ was chosen as the first 159 digits of the
Euler number $e$.}
$$
\begin{array}{r@{\:}c@{\:}l}
y & = & \lfloor 10^{159}e\rfloor \\
  & = & 271828182845904523536028747135266249775724709369995957496696 \\
  &   & 762772407663035354759457138217852516642742746639193200305992 \\
  &   & 1817413596629043572900334295260595630738 \\
k & = & \log_g(y)\mod p\\
  & = & 829897164650348970518646802640757844024961469323126472198531 \\
&   & 845186895984026448342666252850466126881437617381653942624307 \\
&   & 537679319636711561053526082423513665596
\end{array}
$$
The search was performed with GNFS method (General Number Field Sieve,
Index-Calculus) \index{General Number Field Sieve (GNFS)} and took about
17 CPU years on 3.2 GHz Xeon machines.
 
%--------------------------------------------------------------------
\subsection[Diffie-Hellman key agreement]
{Diffie-Hellman key agreement\footnotemark}
\footnotetext{%
  With CT1\index{CrypTool 1} this exchange protocol has been
  visualized: you can execute the single steps with concrete numbers using 
  menu {\bf Indiv. Procedures \textbackslash{} Protocols \textbackslash{}
  Diffie-Hellman Demonstration}.\\
  In JCT\index{JCrypTool} you can find it in the default perspective
  via the menu item {\bf Visuals \textbackslash{} Diffie-Hellman Key
  Exchange (EC)}.
}

\index{Key agreement (key exchange)!Diffie-Hellman} 
\index{Diffie, Whitfield}
\index{Hellman, Martin}
\index{Diffie-Hellman}
\hypertarget{DH-KeyExch}{} \label{DH-KeyExch}

The mechanisms and 
algorithms of classical cryptography only take effect when the subscribers have 
already exchanged the secret key. In classical cryptography you cannot avoid 
exchanging secrets without encrypting them. Transmission safety here must be 
achieved using non-cryptographic methods. We say that we need a secret channel 
for exchanging secrets. This channel can be realised either physically or 
organisationally. \\
What is revolutionary about modern cryptography is, amongst other things, that 
you no longer need secret channels: You can agree secret keys using non-secret, 
i.e. public channels. \\
One protocol that solves this problem is that of Diffie and Hellman (crypto 
procedure~\ref{diffiehellmanproc}).
\begin{cryptoprocedure}
Two subscribers $ A $ and $ B $ want to agree on a joint secret key. \par
Let $ p $ be a prime number and $ g $ a natural number. These two numbers do not 
need to be secret. \\
The two subscribers then select a secret number $ a $ and $ b$ from which they 
calculate the values $ \alpha = g^{a}\mod p $ and $ \beta = g^b \mod p. $ They 
then exchange the numbers $ \alpha $ and $ \beta $. To end with, the two 
subscribers calculate the received value to the power of their secret value to 
get $ \beta^{a} \mod p $ and $ \alpha^b \mod p. $\\
Thus
\[ \beta^{a} \equiv (g^b)^{a} \equiv g^{ba} \equiv g^{ab} \equiv (g^{a})^b 
\equiv \alpha^b \mod p \]
\caption{Diffie-Hellman key agreement}
\label{diffiehellmanproc}
\end{cryptoprocedure}

The safety of the {\bf Diffie-Hellman protocol} is closely connected to 
calculating the discrete logarithm mod $p$\index{Logarithm}. It is even thought that these 
problems are equivalent.

%--------------------------------------------------------------------
\subsection{ElGamal public key encryption procedure in \texorpdfstring{$ \Z_p^\ast$}{Zp*}}
\index{ElGamal!public key}
\index{Encryption!ElGamal public key}

By varying the Diffie-Hellman key agreement protocol\index{Diffie-Hellman} 
slightly, you can obtain an asymmetric encryption algorithm, crypto
procedure~\ref{elgamalproc}. This observation was made by Taher ElGamal.
\begin{cryptoprocedure}
Let $ p $ be a prime number such that the discrete logarithm in $ \Z_p $ is 
difficult to compute. Let $ \alpha \in \Z_p^\ast $ be a primitive element. Let $a \in \N$ and $ 
\beta = \alpha^{a}  \mod p. $\\
\textbf{Public key:}
\[ p,\alpha,\beta. \]
\textbf{Private key:}
\[a. \]
Let $ k \in \Z_{p-1} $ be a random number and $ x \in \Z_p^{\ast} $ the 
plaintext. \\
\textbf{Encryption:}
\[ e_T(x,k)=(y_1,y_2), \]
where
\[ y_1=\alpha^k \mod p\]
and
\[ y_2 = x\beta^k \mod p.\]
\textbf{Decryption:}
\[ d_T(y_1,y_2)= y_2 (y_1^{a})^{-1} \mod p \]
\caption{ElGamal (based on the discrete logarithm problem)}
\label{elgamalproc}
\end{cryptoprocedure}



%--------------------------------------------------------------------
\subsection{Generalised ElGamal public key encryption procedure}

The discrete logarithm can be generalised in any number of finite \index{Group} 
groups $ (G, \circ) $. The following provides several properties of $ G, $ that 
make the discrete logarithm problem difficult. \\
\index{Exponential function!calculation}
\paragraph*{Calculating the discrete exponential function}
Let $ G $ be a group with the operation $ \circ $ and $ g \in G. $ The 
(discrete) exponential function  base $ g $ is defined as
\[ e_g : k \longmapsto g^k, \quad {\rm for~all~} k \in {\rm N}. \]
where
 \[ \ g^{k}:=\underbrace{g \circ \ldots \circ g}_{k {\rm ~times}}.\]
The exponential function is easy to calculate:

\vskip +10 pt \noindent
{\bf Lemma.}
{\em
\noindent The power $ g^k $ can be calculated in at most $ 2 \log_2 k $ group 
operations.
}

\vskip +10 pt
\begin{Proof}{}
Let $ k=2^n + k_{n-1} 2^{n-1} + \cdots + k_1 2 + k_0 $ be the binary 
representation of $k. $ Then $ n \leq \log_2 (k), $  because $ 2^n \leq k < 
2^{n+1}. $ $ k $ can be written in the form $ k=2k' + k_0 $ with $ k'= 2^{n-1} + 
k_{n-1} 2^{n-2} + \cdots + k_1 $. Thus 
\[ g^k = g^{2k'+k_0}= (g^{k'})^2 g^{k_0} .\]
We therefore obtain $ g^k $ from $ g^{k'} $ by squaring and then multiplying by 
$ g $. The claim is thus proved by induction to $ n. $
\end{Proof}

\vskip +10 pt
\noindent {\bf Problem of the discrete logarithm}\index{Logarithm problem!discrete}
\vskip +10 pt
\begin{center}
\fbox{\parbox{12cm}{        
Let $ G $ by a finite group with the operation $ \circ. $ Let $ \alpha \in G $ 
and $ \beta \in H=\{ \alpha^{i}: i\geq 0\}. $ \\
We need to find a unique $ a \in {\rm N} $ with $ 0 \leq a \leq |H| -1 $ and $ \beta 
= \alpha^{a}. $ \\       
We define $ a $ as $ \log_\alpha (\beta). $
}}
\end{center}

\paragraph*{Calculating the discrete logarithm }
A simple procedure for calculating the discrete logarithm of a group element, 
that is considerably more efficient than simply trying all possible values for $ 
k, $ is the \index{Baby-step-giant-step} baby-step-giant-step algorithm.
\begin{theorem}\label{thm-cry-bsgs}[baby-step-giant-step algorithm]
Let $ G $ be a group and $ g \in G. $ Let $ n $ be the smallest natural number 
with $ |G|\leq n^2. $ Then the discrete logarithm of an element $ h 
\in G $ can be calculated base $ g $ by generating two lists each containing $ n 
$ elements and comparing these lists.\\
In order to calculate these lists, we need $ 2n $ group operations.
\end{theorem}

\begin{Proof}{}
  First create the two lists \\
Giant-step list: $ \{1,g^n,g^{2n}, \ldots, g^{n \cdot n}\}, $\\
Baby-step list: $ \{ hg^{-1} , hg^{-2} , \ldots , hg^{-n} \}. $ \par
If $ g^{jn} = hg^{-i}, $ i.e. $ h = g^{i+jn}, $ then the problem is solved. If 
the lists are disjoint, then $ h $ cannot be represented as $ g^{i + jn}, i, 
j\leq n,$. As all powers of $ g $ are thus recorded, the logarithm problem does 
not have a solution.
\end{Proof}

You can use the baby-step-giant-step algorithm to demonstrate that it is much 
more difficult to calculate the discrete logarithm than to calculate the 
discrete exponential function. If the numbers that occur have approximately 1000 
bits in length, then you only need around 2000 multiplications to calculate $ 
g^k $ but around $ 2^{500} \approx 10^{150} $ operations to calculate the 
discrete logarithm using the baby-step-giant-step algorithm. \\
In addition to the baby-step-giant-step algorithm, there are also numerous other 
procedures for calculating the discrete logarithm \cite{mc:4Stinson1995}\index{Stinson 1995}.

\paragraph*{The theorem from Silver-Pohlig-Hellman}
In finite Abelian groups, the discrete logarithm problem can be reduced to 
groups of a lower order.
\begin{theorem}\label{thm-cry-pohe}[Silver-Pohlig-Hellman]
Let $ G $ be a finite Abelian group with $ |G|= p_1^{a_1} p_2^{a_2} \cdot \ldots 
\cdot p_s^{a_s}. $ The discrete logarithm in $ G $ can then be reduced to 
solving logarithm problems in groups of the order $ p_1, \ldots , p_s $.
\end{theorem}

\noindent If $ |G| $ contains a ``dominant'' prime factor $ p ,$ then the 
complexity \index{Complexity} of the logarithm problem is approximately
\[ O(\sqrt{p}). \]

\noindent Therefore, if the logarithm problem is to be made difficult, the order of the 
group used $ G $ should have a large prime factor. In particular, if the 
discrete exponential function in the group $ \Z_p^{\ast} $ is to be a one way 
function, then $ p -1 $ must be a large prime factor. In this case a
generalized ElGamal procedure can be defined (crypto
procedure~\ref{genelgamalproc}).
\begin{cryptoprocedure}
Let $ G $ be a finite group with operation $  \circ, $ and let $ \alpha \in G, $ 
so that the discrete logarithm in $ H =\{ \alpha^{i}: i \geq 0 \} $ is 
difficult, Let $ a $ with $   0 \leq a \leq |H| -1 $ and let $ \beta = 
\alpha^{a}. $\\
\textbf{Public key:}
\[ \alpha,\beta. \]
\textbf{Private key:}
\[a. \]
Let $ k \in \Z_{|H|} $ be a random number and $ x \in G $ be a plaintext. \\
\textbf{Encryption:}
\[ e_T(x,k)=(y_1,y_2), \]
where
\[ y_1=\alpha^k \]
and
\[ y_2 = x\circ \beta^k .\]
\textbf{Decryption:}
\[ d_T(y_1,y_2)= y_2\circ (y_1^{a})^{-1}  \]
\caption{Generalized ElGamal (based on the factorization problem)}
\label{genelgamalproc}
\end{cryptoprocedure}

\noindent \hyperlink{ellcurve}{Elliptic curves}{} provide useful groups for public key 
encryption procedures.


%--------------------------------------------------------------------
\newpage
\begin{thebibliography}{99}
\addcontentsline{toc}{section}{Bibliography}

   \bibitem[Adleman1982]{mc:Adleman1982} \index{Adleman 1982}
       Adleman L.: \\ 
       \emph{On breaking the iterated Merkle-Hellman public key 
             Cryptosystem.} \\ 
       Advances in Cryptology, Proceedings of Crypto 82, 
       Plenum Press 1983, 303-308.

   \bibitem[Balcazar1988]{mc:Balcazar1988} \index{Balcazar 1988} 
       Balcazar J.L., Daaz J., Gabarr J.: \\ 
       \emph{Structural Complexity I.} \\ 
       Springer Verlag, pp 63.
           
    \bibitem[Brickell1985]{mc:Brickell1985} \index{Brickell 1985}
       Brickell E.F.: \\
       \emph{Breaking Iterated Knapsacks.}  \\
       Advances in Cryptology: Proc. CRYPTO'84, 
       Lecture Notes in Computer Science, vol. 196, 
       Springer-Verlag, New York, 1985, pp. 342-358.

    \bibitem[Hesselink2001]{mc:Hesselink2001} \index{Hesselink 2001} 
       Hesselink Wim H.: \\
       \emph{The borderline between P and NP.} \\
       \url{http://www.cs.rug.nl/~wim/pub/whh237.pdf},\\
       February 12, 2001.

    \bibitem[Lagarias1983]{mc:Lagarias1983} \index{Lagarias 1983} 
       Lagarias J.C.: \\
       \emph{Knapsack public key Cryptosystems and diophantine
             Approximation.} \\
       Advances in Cryptology, Proceedings of Crypto 83, Plenum Press.

    \bibitem[Merkle1978]{mc:Merkle1978} \index{Merkle 1978} 
       Merkle R. and Hellman M.: \\
       \emph{Hiding information and signatures in trapdoor knapsacks.} \\
       IEEE Trans. Information Theory, IT-24, 1978.

    \bibitem[RSA1978]{mc:RSA1978} \index{RSA 1978}
       Rivest R.L., Shamir A. and Adleman L.: \\
       \emph{A Method for Obtaining Digital Signatures and 
             Public Key Cryptosystems.} \\
       Commun. ACM, vol 21, April 1978, pp. 120-126.

    \bibitem[Shamir1982]{mc:Shamir1982} \index{Shamir 1982}
       Shamir A.: \\
       \emph{A polynomial time algorithm for breaking the basic 
             Merkle-Hellman Cryptosystem.} \\
       Symposium on Foundations of Computer Science (1982), 145-152.
           
%already defined in elementaryNumberTheory.tex
    \bibitem[Stinson1995]{mc:4Stinson1995} \index{Stinson 1995}
       Stinson D.R.: \\
       \emph{Cryptography.} \\
       CRC Press, Boca Raton, London, Tokyo, 1995.

\end{thebibliography}


%--------------------------------------------------------------------
%\newpage
%\chapter*{Web links}
%% \section*{Web links}   %%% TODO: einheitlich section oder chapter für Web-Links
                         %%% TODO: einheitlich addcontentsline NACH WebLinks und NACH Bibliography
%\addcontentsline{toc}{section}{Web links}
%\begin{enumerate}
%   \item \url{http://www.geocities.com/st_busygin/clipat.html}
%\end{enumerate}

% Local Variables:
% TeX-master: "../script-en.tex"
% End:
